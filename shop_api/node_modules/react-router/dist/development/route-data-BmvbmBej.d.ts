import * as React from 'react';
import { ComponentType, ReactElement } from 'react';

/**
 * Actions represent the type of change to a location value.
 */
declare enum Action {
    /**
     * A POP indicates a change to an arbitrary index in the history stack, such
     * as a back or forward navigation. It does not describe the direction of the
     * navigation, only that the current index changed.
     *
     * Note: This is the default action for newly created history objects.
     */
    Pop = "POP",
    /**
     * A PUSH indicates a new entry being added to the history stack, such as when
     * a link is clicked and a new page loads. When this happens, all subsequent
     * entries in the stack are lost.
     */
    Push = "PUSH",
    /**
     * A REPLACE indicates the entry at the current index in the history stack
     * being replaced by a new one.
     */
    Replace = "REPLACE"
}
/**
 * The pathname, search, and hash values of a URL.
 */
interface Path {
    /**
     * A URL pathname, beginning with a /.
     */
    pathname: string;
    /**
     * A URL search string, beginning with a ?.
     */
    search: string;
    /**
     * A URL fragment identifier, beginning with a #.
     */
    hash: string;
}
/**
 * An entry in a history stack. A location contains information about the
 * URL path, as well as possibly some arbitrary state and a key.
 */
interface Location<State = any> extends Path {
    /**
     * A value of arbitrary data associated with this location.
     */
    state: State;
    /**
     * A unique string associated with this location. May be used to safely store
     * and retrieve data in some other storage API, like `localStorage`.
     *
     * Note: This value is always "default" on the initial location.
     */
    key: string;
}
/**
 * A change to the current location.
 */
interface Update {
    /**
     * The action that triggered the change.
     */
    action: Action;
    /**
     * The new location.
     */
    location: Location;
    /**
     * The delta between this location and the former location in the history stack
     */
    delta: number | null;
}
/**
 * A function that receives notifications about location changes.
 */
interface Listener {
    (update: Update): void;
}
/**
 * Describes a location that is the destination of some navigation used in
 * {@link Link}, {@link useNavigate}, etc.
 */
type To = string | Partial<Path>;
/**
 * A history is an interface to the navigation stack. The history serves as the
 * source of truth for the current location, as well as provides a set of
 * methods that may be used to change it.
 *
 * It is similar to the DOM's `window.history` object, but with a smaller, more
 * focused API.
 */
interface History {
    /**
     * The last action that modified the current location. This will always be
     * Action.Pop when a history instance is first created. This value is mutable.
     */
    readonly action: Action;
    /**
     * The current location. This value is mutable.
     */
    readonly location: Location;
    /**
     * Returns a valid href for the given `to` value that may be used as
     * the value of an <a href> attribute.
     *
     * @param to - The destination URL
     */
    createHref(to: To): string;
    /**
     * Returns a URL for the given `to` value
     *
     * @param to - The destination URL
     */
    createURL(to: To): URL;
    /**
     * Encode a location the same way window.history would do (no-op for memory
     * history) so we ensure our PUSH/REPLACE navigations for data routers
     * behave the same as POP
     *
     * @param to Unencoded path
     */
    encodeLocation(to: To): Path;
    /**
     * Pushes a new location onto the history stack, increasing its length by one.
     * If there were any entries in the stack after the current one, they are
     * lost.
     *
     * @param to - The new URL
     * @param state - Data to associate with the new location
     */
    push(to: To, state?: any): void;
    /**
     * Replaces the current location in the history stack with a new one.  The
     * location that was replaced will no longer be available.
     *
     * @param to - The new URL
     * @param state - Data to associate with the new location
     */
    replace(to: To, state?: any): void;
    /**
     * Navigates `n` entries backward/forward in the history stack relative to the
     * current index. For example, a "back" navigation would use go(-1).
     *
     * @param delta - The delta in the stack index
     */
    go(delta: number): void;
    /**
     * Sets up a listener that will be called whenever the current location
     * changes.
     *
     * @param listener - A function that will be called when the location changes
     * @returns unlisten - A function that may be used to stop listening
     */
    listen(listener: Listener): () => void;
}
/**
 * A user-supplied object that describes a location. Used when providing
 * entries to `createMemoryHistory` via its `initialEntries` option.
 */
type InitialEntry = string | Partial<Location>;
/**
 * A browser history stores the current location in regular URLs in a web
 * browser environment. This is the standard for most web apps and provides the
 * cleanest URLs the browser's address bar.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory
 */
interface BrowserHistory extends UrlHistory {
}
type BrowserHistoryOptions = UrlHistoryOptions;
/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */
declare function createBrowserHistory(options?: BrowserHistoryOptions): BrowserHistory;
/**
 * @private
 */
declare function invariant(value: boolean, message?: string): asserts value;
declare function invariant<T>(value: T | null | undefined, message?: string): asserts value is T;
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 *
 * @category Utils
 */
declare function createPath({ pathname, search, hash, }: Partial<Path>): string;
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 *
 * @category Utils
 */
declare function parsePath(path: string): Partial<Path>;
interface UrlHistory extends History {
}
type UrlHistoryOptions = {
    window?: Window;
    v5Compat?: boolean;
};

/**
 * Map of routeId -> data returned from a loader/action/error
 */
interface RouteData {
    [routeId: string]: any;
}
type LowerCaseFormMethod = "get" | "post" | "put" | "patch" | "delete";
type UpperCaseFormMethod = Uppercase<LowerCaseFormMethod>;
/**
 * Users can specify either lowercase or uppercase form methods on `<Form>`,
 * useSubmit(), `<fetcher.Form>`, etc.
 */
type HTMLFormMethod = LowerCaseFormMethod | UpperCaseFormMethod;
/**
 * Active navigation/fetcher form methods are exposed in uppercase on the
 * RouterState. This is to align with the normalization done via fetch().
 */
type FormMethod = UpperCaseFormMethod;
type FormEncType = "application/x-www-form-urlencoded" | "multipart/form-data" | "application/json" | "text/plain";
type JsonObject = {
    [Key in string]: JsonValue;
} & {
    [Key in string]?: JsonValue | undefined;
};
type JsonArray = JsonValue[] | readonly JsonValue[];
type JsonPrimitive = string | number | boolean | null;
type JsonValue = JsonPrimitive | JsonObject | JsonArray;
/**
 * @private
 * Internal interface to pass around for action submissions, not intended for
 * external consumption
 */
type Submission = {
    formMethod: FormMethod;
    formAction: string;
    formEncType: FormEncType;
    formData: FormData;
    json: undefined;
    text: undefined;
} | {
    formMethod: FormMethod;
    formAction: string;
    formEncType: FormEncType;
    formData: undefined;
    json: JsonValue;
    text: undefined;
} | {
    formMethod: FormMethod;
    formAction: string;
    formEncType: FormEncType;
    formData: undefined;
    json: undefined;
    text: string;
};
/**
 * @private
 * Arguments passed to route loader/action functions.  Same for now but we keep
 * this as a private implementation detail in case they diverge in the future.
 */
interface DataFunctionArgs<Context> {
    /** A {@link https://developer.mozilla.org/en-US/docs/Web/API/Request Fetch Request instance} which you can use to read headers (like cookies, and {@link https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams URLSearchParams} from the request. */
    request: Request;
    /**
     * {@link https://reactrouter.com/start/framework/routing#dynamic-segments Dynamic route params} for the current route.
     * @example
     * // app/routes.ts
     * route("teams/:teamId", "./team.tsx"),
     *
     * // app/team.tsx
     * export function loader({
     *   params,
     * }: Route.LoaderArgs) {
     *   params.teamId;
     *   //        ^ string
     * }
     **/
    params: Params;
    /**
     * This is the context passed in to your server adapter's getLoadContext() function.
     * It's a way to bridge the gap between the adapter's request/response API with your React Router app.
     * It is only applicable if you are using a custom server adapter.
     */
    context?: Context;
}
/**
 * Arguments passed to loader functions
 */
interface LoaderFunctionArgs<Context = any> extends DataFunctionArgs<Context> {
}
/**
 * Arguments passed to action functions
 */
interface ActionFunctionArgs<Context = any> extends DataFunctionArgs<Context> {
}
/**
 * Loaders and actions can return anything except `undefined` (`null` is a
 * valid return value if there is no data to return).  Responses are preferred
 * and will ease any future migration to Remix
 */
type DataFunctionValue = Response | NonNullable<unknown> | null;
type DataFunctionReturnValue = Promise<DataFunctionValue> | DataFunctionValue;
/**
 * Route loader function signature
 */
type LoaderFunction<Context = any> = {
    (args: LoaderFunctionArgs<Context>, handlerCtx?: unknown): DataFunctionReturnValue;
} & {
    hydrate?: boolean;
};
/**
 * Route action function signature
 */
interface ActionFunction<Context = any> {
    (args: ActionFunctionArgs<Context>, handlerCtx?: unknown): DataFunctionReturnValue;
}
/**
 * Arguments passed to shouldRevalidate function
 */
interface ShouldRevalidateFunctionArgs {
    /** This is the url the navigation started from. You can compare it with `nextUrl` to decide if you need to revalidate this route's data. */
    currentUrl: URL;
    /** These are the {@link https://reactrouter.com/start/framework/routing#dynamic-segments dynamic route params} from the URL that can be compared to the `nextParams` to decide if you need to reload or not. Perhaps you're using only a partial piece of the param for data loading, you don't need to revalidate if a superfluous part of the param changed. */
    currentParams: AgnosticDataRouteMatch["params"];
    /** In the case of navigation, this the URL the user is requesting. Some revalidations are not navigation, so it will simply be the same as currentUrl. */
    nextUrl: URL;
    /** In the case of navigation, these are the {@link https://reactrouter.com/start/framework/routing#dynamic-segments dynamic route params}  from the next location the user is requesting. Some revalidations are not navigation, so it will simply be the same as currentParams. */
    nextParams: AgnosticDataRouteMatch["params"];
    /** The method (probably `"GET"` or `"POST"`) used in the form submission that triggered the revalidation. */
    formMethod?: Submission["formMethod"];
    /** The form action (`<Form action="/somewhere">`) that triggered the revalidation. */
    formAction?: Submission["formAction"];
    /** The form encType (`<Form encType="application/x-www-form-urlencoded">) used in the form submission that triggered the revalidation*/
    formEncType?: Submission["formEncType"];
    /** The form submission data when the form's encType is `text/plain` */
    text?: Submission["text"];
    /** The form submission data when the form's encType is `application/x-www-form-urlencoded` or `multipart/form-data` */
    formData?: Sub—áo HUØH‰HÇB   L‰ñE1ÀèÍvÿHƒøÿ„¶   H‰ÇHƒÇH‹EğH9øHBøH)øH}èH‰}èH‰EğH…ÿ„•   H‹]ğH¸øÿÿÿÿÿÿH9Ãƒ£   Hƒûv6H!ØHƒÀI‰ŞIƒÎIƒşLDğIÿÆL‰ñè [S H‰ÁH‰Iºî?L‰vH‰^ëˆ^H‰ñL4H9ùwI9şw>H…ÛtH‰úI‰Øè2W AÆ H‰ğHÄ€   [_^A^]ÃH‹}èébÿÿÿWÀHÇF    ëÖHaÄ[ HFÒ[ èVØX ëH‰ñèœOW Ìff.„     H‰T$UAVVWSHƒì Hª€   èÕpS ÌÌÌÌÌUAVVWSHƒìPHl$PHÇEøşÿÿÿH‰ÎHÂ[ HMèH‰HÇA    H)ào HUØH‰HÇB   E1Àè¢ËvÿHƒøÿ„¯   H‰ÇH‹EğH9øHBøH)øH}èH‰}èH‰EğH…ÿ„’   H‹]ğH¸øÿÿÿÿÿÿH9Ãƒ    Hƒûv6H!ØHƒÀI‰ŞIƒÎIƒşLDğIÿÆL‰ñè”YS H‰ÁH‰Iºî?L‰vH‰^ëˆ^H‰ñL4H9ùwI9şw;H…ÛtH‰úI‰Øè›0W AÆ H‰ğHƒÄP[_^A^]ÃH‹}èéeÿÿÿWÀHÇF    ëÙHøÂ[ HİĞ[ èíÖX ëH‰ñè3NW ÌfH‰T$UAVVWSHƒì HjPèxoS ÌÌÌÌÌÌÌÌUAVVWSHì   H¬$€   )upHÇEhşÿÿÿH‰Î1ÀHU H‰BWÀ)HM AH‰AH¸
      H‰A H3¹[ H‰H‰Q(1ÒE1ÀE1ÉèvÿI¾ªªªªªªªªH]àL‰s(5~½[ )3H‰ÙèóûÿÿH}PL‰w)7HAÀ[ H‰ùèyNW H¾E÷H…ÀyH‹EèH…ÀtH‹E8H;E0r%HM ²(èqvÿë#H¾EgH…ÀyH‹EXH…ÀuÖé½   HHH‰M8Æ (H¾E÷I‰ÀH…ÀyL‹EèM…Àt„ÀyH‹]àHM H‰Úè"vÿH¾EgH…ÀyH‹EXH…ÀtSH¾E÷H…ÀyH‹EèH…Àt"H‹E8H;E0rHM ² èçvÿëHHH‰M8Æ  L¾EgM…ÀLHEXH‹UPHI×HM è¼vÿH‹E8H;E0rHM ²)è§vÿëHHH‰M8Æ )H‰ëL‰s)3H)¿[ H‰ÙèaMW ŠM„ÉL‹E¶ÁH‰ÂIHĞH…Ò„4  L¾MgM‰ÊM…ÉyL‹UXL9Òu?E„ÉyH‹}P„Éx„  1ÉŠT :u!HÿÁH9Èuïéó   H‹M H‰úè-W …À„ß   H‹M0H‹E8H)ÁHƒùwH.7e HM A¸   èévÿë
fÇ  (HƒE8H}ÀL‰w)7H‰ùè*üÿÿH¾E×I‰ÀH…ÀyL‹EÈM…Àt5„ÀyH‹}ÀHM H‰úè vÿH‹HH;HrH‰Á² èŒvÿëHQH‰PÆ L¾EM…ÀLHEHH] HM H‰ÚèavÿH‹HH;HrH‰Á²)èMvÿëHQH‰PÆ)€}× y	H‹MÀèVS H‹E8H;E(t	HM èşvÿH‹EH€x xhH‹HH‰N €} y	H‹M èãUS €}g y	H‹MPèÔUS €}÷ y	H‹MàèÅUS HM è0%vÿ€}· y	H‹M è­US H‰ğ(upHÄ   [_^A^]ÃH‹L‹@H‰ñè.S ë•ff.„     H‰T$UAVVWSHƒì0Hª€   )t$ HM èŒvÿ(t$ HƒÄ0[_^A^]Ãfff.„     H‰T$UAVVWSHƒì0Hª€   )t$ €}× y	H‹MÀèUS (t$ HƒÄ0[_^A^]ÃfD  H‰T$UAVVWSHƒì0Hª€   )t$ €} y	H‹M èÒTS (t$ HƒÄ0[_^A^]ÃfD  H‰T$UAVVWSHƒì0Hª€   )t$ €}g y	H‹MPè’TS (t$ HƒÄ0[_^A^]ÃfD  H‰T$UAVVWSHƒì0Hª€   )t$ €}÷ y	H‹MàèRTS (t$ HƒÄ0[_^A^]ÃfD  H‰T$UAVVWSHƒì0Hª€   )t$ HM èŒ#vÿ(t$ HƒÄ0[_^A^]Ãfff.„     H‰T$UAVVWSHƒì0Hª€   )t$ €}· y	H‹M èÒSS (t$ HƒÄ0[_^A^]ÃÌÌÌÌÌÌVHƒì H‰ÎH‡Ùo èœIW H‰ğHƒÄ ^ÃÌÌÌUAVVWSHƒì@Hl$@HÇEøşÿÿÿI‰ÎH¸ªªªªªªªªH‰A(A¸[ €z xH‹BI‰FA1öH}èL‰uğëjH‹L‹BL‰ñH‰Âè;,S ëàƒø;&ƒø"t&ƒø	„  ƒø
u8A€~ M‰ğ‰ã   éÛ   ƒø<u A€~ M‰ğyM‹IØL‰ñH‰úA±\èËÂX ÿÆÿÆL‹uğI¾FH…ÀyI‹F‰óH9Ø„‰   L‰ñH‰ÚèŸSW ¶ ƒø=zÿÿÿH…ƒùr¢ƒø>tƒø\u¸I¾FH…ÀyI‹FVH9Ğt‚L‰ñècSW ¶ H…ƒùƒŸ   I¾FH…ÀyI‹FH9Ø„–   ‚¥   A¸   L‰ñH‰Úèf•WÿéXÿÿÿL‰ğHƒÄ@[_^A^]ÃM‹IØL‰ñH‰úA±\èÿÁX ÿÆH‹MğH‰òèñRW Æ né ÿÿÿA€~ M‰ğyM‹IØL‰ñH‰úA± èËÁX ÿÆH‹MğH‰òè½RW Æ  éìşÿÿƒøl„ãşÿÿé¾şÿÿHO»[ Hó[ èDÏX ëL‰ñèÊJW Ìf„     H‰T$UAVVWSHƒì Hj@H‹Eğ€x yH‹EğH‹èsQS HƒÄ [_^A^]ÃÌÌÌÌÌÌÌÌÌÌÌUAWAVVWSHì  H¬$€   HÇ…   şÿÿÿL‰ÇH‰ÓH‰ÎAÇ ÿÿÿÿLuØA¸ˆ   L‰ñ²ªèº.W M‰vèM‰vğHEXI‰Fø(Óµ[ HM`)Hgd LE°I‰ IÇ@   HEÀH‰D$ H‰ÚI‰ùè¢Cwÿƒ}` t:ègvÿH‰ÇH‹HH‹@H)ÁHƒù‡m  HÖo A¸   H‰ùèªvÿH‰Çéb  è-vÿH‹PH‹HH)ÊHƒúwHvl A¸	   H‰ÁèwvÿëŠvl ˆQH‹üul H‰Hƒ@	H‹UÀL‹EÈI)ĞH‰ÁèJvÿH‹PH‹HH)ÊHƒúwHÖo A¸   H‰Áè$vÿëÆA Ç'...Hƒ@H‹}ÀH…ÿ„Š   L‹}ÈL‰ûH)ûH¸øÿÿÿÿÿÿH9ÃƒP  Hƒûv6H!ØHƒÀI‰ŞIƒÎIƒşLDğIÿÆL‰ñèrOS H‰ÁH‰Iºî?L‰vH‰^ëˆ^H‰ñL4H9ùw	I9ş‡ç   I9ÿtH‰úI‰Øèu&W AÆ é¥   WÀHÇF    é¨   Hº¹[ A¸   H‰ÁèTvÿëVÇ@or: Ç ErroHƒGHM`H]xH‰ÚèàÉX L¾…   M…ÀLH…€   HH]xH‰ùH‰ÚèvÿH‹HH9HtšÆ
Hÿ@€½    y	H‹MxèÖNS Hƒ¶[ H‰ñè»DW H‹}ÀHEØH9ÇtH…ÿtH‰ùèõNS H‰ğHÄ  [_^A^A_]ÃH&¸[ HÆ[ èÌX ë
H‰ñèaCW ë Ìfffff.„     H‰T$UAWAVVWSHƒì(Hª€   €½    y	H‹MxèBNS HƒÄ([_^A^A_]Ã„     H‰T$UAWAVVWSHƒì(Hª€   H‹MÀHEØH9Át
H…ÉtèENS HƒÄ([_^A^A_]Ã H‰T$UAWAVVWSHƒì(Hª€   èdS ÌÌÌUAWAVATVWSHìp  H¬$€   )µà   HÇ…Ø   şÿÿÿD‰ÇI¼ªªªªªªªªL‰ep(5]²[ )u`H‹1H…ötTH‹YH¸øÿÿÿÿÿÿH9Ãƒ¼  HƒûvHH!ØHƒÀI‰ŞIƒÎIƒşLDğIÿÆL‰ñèMS H‰ÁH‰E`Iºî?L‰upH‰]hëWÀ)E`HÇEp    ë-HM`ˆYL4H9ñw	I9ö‡!  H…ÛtH‰òI‰Øèó#W AÆ WÀHu@)1ÀH‰FHM H‰A)L5ÃÒo HU L‰2HÇB   I‰ğèV  „À…½  HÄÒo HU°H‰HÇB   HM I‰ğè,  „À„±  WÀ)…À   HÇ…Ğ       €}W yH‹u@H•€   H‰2HÀ   è*TÿH‰…È   €}w xHM`ëH‹M`H‰€   H;…Ğ   rHÀ   H•€   èå)TÿëH…À„H  H‰HƒÀH‰…È   HÇ…€       H;…Ğ   rHÀ   H•€   è¥)TÿëH…À„ğ  HÇ     HƒÀH‰…È   èSvÿH‹PH‹HH)ÊHƒúwHÁÑo A¸   H‰Áèvÿë¸Ño AŸÑo Hƒ@èvÿH‹PH‹HH)ÊHƒú$wH×Òo A¸%   H‰ÁèVvÿë(ĞÒo AµÒo Hºsabled.
H‰QHƒ@%H‹À   H…É„²  H‹…È   H9È„–  HƒÀøuñéÇ  WÀ)…À   HÇ…Ğ       €}W yH‹u@H•€   H‰2HÀ   èŒ(TÿH‰…È   €}w xHM`ëH‹M`H‰€   H;…Ğ   rHÀ   H•€   èR(TÿëH…À„…  H‰HƒÀH‰…È   HÇ…€       H;…Ğ   rHÀ   H•€   è(TÿëH…À„-  HÇ     HƒÀH‰…È   èÀvÿH‹PH‹HH)ÊHƒúwHĞo A¸   H‰Áè
vÿëıÏo AåÏo Hƒ@èyvÿH‹PH‹HH)ÊHƒú$wHDÑo A¸%   H‰ÁèÃ vÿë(=Ño A"Ño Hºsabled.
H‰QHƒ@%H‹À   H…Ét#H‹…È   H9ÈtHƒÀøuõé$  H‰È   èVIS 1ö€}7 y	H‹M èEIS €}W y	H‹M@è6IS €}w y	H‹M`è'IS ‰ğ(µà   HÄp  [_^A\A^A_]ÃH‰¨   è IS €½—    yH‹€   èëHS 1ö€½×    yŒH‹À   èÔHS é{ÿÿÿHÏo HUÀH‰HÇB   HM I‰ğèQ  „ÀuhHÏo HUĞH‰HÇB   HM I‰ğè+  ‰Ã„À„.  WÀ)…À   HÇ…Ğ       ƒÿ‡×  ‰øHĞo HcHÈÿàH¼xd é:  WÀ)…À   HÇ…Ğ       €}W yH‹u@H•€   H‰2HÀ   èà%TÿH‰…È   €}w xHM`ëH‹M`H‰€   H;…Ğ   rHÀ   H•€   è¦%TÿëH…À„i  H‰HƒÀH‰…È   HÎo H‰€   H;…Ğ   rHÀ   H•€   èc%TÿëH…À„  H‰HƒÀH‰…È   ƒÿ‡Ì  ‰ùH<Ïo HcŠHÑÿáHÊwd éŒ  HUàL‰2HÇB   HM LE@è×  WÀ)…À   HÇ…Ğ       „À…®şÿÿH5Îo HUH‰HÇB   Hu H}@H‰ñI‰øè‘  „À„  WÀ)…€   HÇ…       €}W yH‹}@H•    H‰:H€   è„$TÿH‰…ˆ   €}w xHM`ëH‹M`H‰    H;…   rH€   H•    èJ$TÿëH…À„m  H‰HƒÀH‰…ˆ   HÇ…        H;…   rH€   H•    è
$TÿëH…À„  HÇ     HƒÀH‰…ˆ   è¸vÿH‹PH‹HH)ÊHƒú‡ƒ  H$Ío A¸   H‰Áèşüuÿéƒ  H‹Ío ëHŒÍo ëH}Ío ëH€Ío H‰€   H;…Ğ   rHÀ   H•€   èt#TÿëH…À„
  H‰HƒÀH‰…È   HÇ…€       H;…Ğ   rHÀ   H•€   è4#TÿëH…À„¯	  HÇ     HƒÀH‰…È   èâvÿH‹PH‹HH)ÊHƒúwHËo A¸   H‰Áè,üuÿëuËo A]Ëo Hƒ@è›vÿH‹PH‹HH)ÊHƒú$wHfÌo A¸%   H‰Áèåûuÿë(_Ìo ADÌo Hºsabled.
H‰QHƒ@%H‹À   H…É„AûÿÿH‹…È   H9È„%ûÿÿHƒÀøuñén  ¬Ëo A–Ëo Hƒ@èvÿH‹PH‹HH)ÊHƒú$wHÌËo A¸%   H‰ÁèKûuÿë(ÅËo AªËo Hºsabled.
H‰QHƒ@%H‹€   H…É„ûÿÿH‹…ˆ   H9ÈtHƒÀøuõé   H‰ˆ   éêúÿÿèyvÿH‹PH‹HH)ÊHƒú3wHËo A¸4   H‰ÁèÃúuÿë,Ëo A óÊo AØÊo ÇA0am:
Hƒ@4è vÿL¾E7M…ÀLHE(HHu H‰ÁH‰òèsúuÿH‹HH9HtÆ
Hÿ@@¶é]úÿÿ@¶H¨­[ A¸   H‰ÁèBúuÿé@úÿÿHÙÊo ëHÊÊo ëHÍÊo ëH´Êo H}ğH‰è/U H‰GHM L½À   H‰úM‰øè…  „Àu-HPÉo H‰êH‰HÇB   HM L…À   è\  „À„šûÿÿH½€   L‰g)7L/Éo Lu`H‰ùL‰òè0¹X WÀ)…    HÇ…°       €½×    yL‹½À   H•¸   L‰:H    è% TÿH‰…¨   HÛÈo H‰¸   H;…°   rH    H•¸   èôTÿëH…À„÷  H‰HƒÀH‰…¨   HÈo H‰¸   H;…°   rH    H•¸   è±TÿëH…À„œ  H‰HƒÀH‰…¨   HmÈo H‰¸   H;…°   rH    H•¸   ènTÿëH…À„A  H‰HƒÀH‰…¨   €}w yL‹u`L‰µ¸   H;…°   rH    H•¸   è(TÿëH…À„ã  L‰0HƒÀH‰…¨   HòÇo H‰¸   H;…°   rH    H•¸   èåTÿëH…À„ˆ  H‰HƒÀH‰…¨   €½—    yH‹½€   H‰½¸   H;…°   rH    H•¸   è™TÿëH…À„$  H‰8HƒÀH‰…¨   HÇ…¸       H;…°   rH    H•¸   èYTÿëH…À„Ì  HÇ     HƒÀH‰…¨   èvÿH‹PH‹HH)ÊHƒúwHÇo A¸	   H‰ÁèQ÷uÿëHºRunning H‰ÆA'Hƒ@	H•À   L¾BM…ÀLHBHHH‰Áè÷uÿH‹PH‹HH)ÊHƒúwH¸Æo A¸   H‰Áèóöuÿë Hºgram... H‰QHº' prograH‰Hƒ@è\vÿH‹PH‹HH)ÊHƒú$wH'Ço A¸%   H‰Áè¦öuÿë( Ço AÇo Hºsabled.
H‰QHƒ@%H‹…    H‹¨   H9ÁtHƒÁøuõéT  H‰…¨   €}W yH‹u@H‰µ¸   H;…°   rH    H•¸   èêTÿëH…À„Å  H‰0HƒÀH‰…¨   „Û„‹   HÇÅo H‰¸   H;…°   rH    H•¸   èŸTÿëH…À„ì  H‰HƒÀH‰…¨   €½—    x	H€   ëH‹€   H‰¸   H;…°   s
H…ÀuaéÀ  H    H•¸   è@TÿëN€½—    x	H€   ëH‹€   H‰¸   H;…°   rH    H•¸   èTÿëH…À„:  H‰HƒÀH‰…¨   HÇ…¸       H;…°   rH    H•¸   èÂTÿëH…À„µ  HÇ     HƒÀH‰…¨   èpvÿH‹PH‹HH)ÊHƒú$wH;Åo A¸%   H‰Áèºôuÿë(4Åo AÅo Hºsabled.
H‰QHƒ@%H‹    H…É„lôÿÿH‹…¨   H9È„PôÿÿHƒÀøuñHâ¦[ HU¦[ è×ºX éÏ  HÊ¦[ H=¦[ è¿ºX é·  H²¦[ H%¦[ è§ºX éŸ  Hš¦[ H¦[ èºX é‡  H‚¦[ Hõ¥[ èwºX éo  Hj¦[ HO´[ è_ºX éW  HR¦[ HÅ¥[ èGºX é?  H:¦[ H$ß[ è/ºX é'  H"¦[ Hß[ èºX é  H
¦[ HôŞ[ èÿ¹X é÷  Hò¥[ HÜŞ[ èç¹X éß  HÚ¥[ HÄŞ[ èÏ¹X éÇ  HÂ¥[ H¬Ş[ è·¹X é¯  Hª¥[ H”Ş[ èŸ¹X é—  H’¥[ H|Ş[ è‡¹X é  Hz¥[ HdŞ[ èo¹X ég  Hb¥[ HLŞ[ èW¹X éO  HJ¥[ H4Ş[ è?¹X é7  H2¥[ HŞ[ è'¹X é  H¥[ HŞ[ è¹X é  H¥[ Hìİ[ è÷¸X éï   Hê¤[ HÔİ[ èß¸X é×   HÒ¤[ H¼İ[ èÇ¸X é¿   Hº¤[ H¤İ[ è¯¸X é§   H¢¤[ HŒİ[ è—¸X é   HŠ¤[ Htİ[ è¸X ëzHu¤[ H_İ[ èj¸X ëeH`¤[ HJİ[ èU¸X ëPHK¤[ H5İ[ è@¸X ë;HM`è…/W H}Àf HvÁo A¸   èL†wÿHdÀf H]Áo A¸   è3†wÿÌfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…ˆ       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…ˆ       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…¨       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…¨       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…¨       (t$ HƒÄ0[_^A\A^A_]ÃH9ÈteHƒÀøuõH¯¢[ H"¢[ è¤¶X Ì H‰T$UAWAVATVWSHƒì0Hª€   )t$ H‹€   H…Ét	H‹…ˆ   ëª(t$ HƒÄ0[_^A\A^A_]ÃH‰ˆ   è¸8S ëŞf.„     H‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…¨       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…¨       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…¨       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…¨       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…¨       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…¨       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…¨       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…¨       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…¨       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…È       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…È       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…È       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…È       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…È       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…È       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…È       (t$ HƒÄ0[_^A\A^A_]ÃfH‰T$UAWAVATVWSHƒì0Hª€   )t$ HÇ…È       (t$ HƒÄ0[_^A\A^A_]ÃH9ÈtQHƒÀøuõHï[ Hb[ èä±X Ì H‰T$UAWAVATVWSHƒì0Hª€   )t$ H‹À   H…ÉtH‹…È   ëªH‰È   è4S (t$ HƒÄ0[_^A\A^A_]ÃH9ÈtoHƒÀøuõHy[ Hìœ[ èn±X Ìffff.„     H‰T$UAWAVATVWSHƒì0Hª€   )t$ H‹À   H…Ét	H‹…È   ë (t$ HƒÄ0[_^A\A^A_]ÃH‰È   èx3S ëŞH9È„~   HƒÀøuñHóœ[ Hfœ[ èè°X Ì€    H‰T$UAWAVATVWSHƒì0Hª€   )t$ H‹    H…Ét	H‹…¨   ë¢€½—    yH‹€   è3S (t$ HƒÄ0[_^A\A^A_]ÃH‰¨   èã2S ëÉD  H‰T$UAWAVATVWSHƒì0Hª€   )t$ €½×    yH‹À   è¨2S (t$ HƒÄ0[_^A\A^A_]ÃH9ÈtkHƒÀøuõHœ[ Hˆ›[ è
°X Ìf„     H‰T$UAWAVATVWSHƒì0Hª€   )t$ H‹À   H…Ét	H‹…È   ë¤(t$ HƒÄ0[_^A\A^A_]ÃH‰È   è2S ëŞf.„     H‰T$UAWAVATVWSHƒì0Hª€   )t$ è,HS Ìff.„     H‰T$UAWAVATVWSHƒì0Hª€   )t$ èüGS Ìff.„     H‰T$UAWAVATVWSHƒì0Hª€   )t$ €}7 y	H‹M è~1S €}W y	H‹M@èo1S €}w y	H‹M`è`1S (t$ HƒÄ0[_^A\A^A_]ÃH‰T$UAWAVATVWSHƒì0Hª€   )t$ èlGS Ìff.„     H‰T$UAWAVATVWSHƒì0Hª€   )t$ è<GS Ìff.„     H‰T$UAWAVATVWSHƒì0Hª€   )t$ èGS Ìff.„     H‰T$UAWAVATVWSHƒì0Hª€   )t$ èÜFS Ìff.„     H‰T$UAWAVATVWSHƒì0Hª€   )t$ è¬FS ÌÌÌÌÌÌÌÌÌÌÌÌUAWAVAUATVWSHìx  H¬$€   )½à   )µĞ   HÇ…È   şÿÿÿL‰…    H‰ÖWÀHUpBHÇB    H¸
      H‰B HR[ H‰H‰J(H‰Ñ1ÒE1ÀE1Éè3åuÿH¤Rb H}¨A¸˜   H‰ùèÊW HMÀH‰IèH‰IğHE@H‰AøHÒËd LE@I‰ IÇ@   ÆD$ H‰ñH‰úA¹ÿÿÿÿèê¤vÿL‹m¨L‹u°L½°   (5D”[ WÿH¨   ëGH‰ùL‰âI‰ğèjæuÿH‰ÇH‹HH‹GH)ÈHƒøwA¸   H‰ùH‰`e èAæuÿë
fÇ'
HƒGIƒÅM9õ„G  M‹e I‹uHÇ…¨   ÿÿÿÿH¸ªªªªªªªªI‰GA7)}PL‰e`H‰uhH‰ÙHU`LEPèÇØ‡ÿö…À   „¦   H‹€   H‹…ˆ   H)ÁHƒùwA¸	   HMpH¶o è­åuÿH‰ÇH‹Hë'H¹  Tried H‰Æ@'H‹ˆ   HƒÁ	H‰ˆ   H}pH‹GH)ÈH9Æ‡õşÿÿH…ö„ÿÿÿL‰âI‰ğèIW HwH‰wH‰ñéæşÿÿH‹•¨   L‹…°   è6S ë5H‹    H9Ët)€y Š…¿   ˆ   „ÀxËH‹…¸   H‰A…¨   ö…À   u€½¿    yH‹¨   èÍ-S H‹M¨HEÀH9Át
H…Étèş-S M9õ•ÃHMpèıuÿ‰Ø(µĞ   (½à   HÄx  [_^A\A]A^A_]ÃD¶À„ÀLH…°   HH¨   H‰Úè©S éuÿÿÿ@ H‰T$UAWAVAUATVWSHƒìHHª€   )|$ )t$0ö…À   u€½¿    yH‹¨   è-S (t$0(|$ HƒÄH[_^A\A]A^A_]ÃH‰T$UAWAVAUATVWSHƒìHHª€   )|$ )t$0HMpèöuÿ(t$0(|$ HƒÄH[_^A\A]A^A_]ÃfD  H‰T$UAWAVAUATVWSHƒìHHª€   )|$ )t$0H‹M¨HEÀH9Át
H…Étè·,S HMpèÚûuÿ(t$0(|$ HƒÄH[_^A\A]A^A_]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌAWAVVWSHƒì@D‰ËH‰ĞH‰ÎDŠ´$   H‹• H1áH‰L$8L‰WÀF€f üL‰ÁHÁé ŠV(Fõ    €âòDÊˆV(A9ÈtVL~H|$(H‰ñH‰úI‰Àè  olean);
}
/**
 * Check if the given error is an ErrorResponse generated from a 4xx/5xx
 * Response thrown from an action/loader
 *
 * @category Utils
 */
declare function isRouteErrorResponse(error: any): error is ErrorResponse;

/**
 * A Router instance manages all navigation and data loading/mutations
 */
interface Router {
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Return the basename for the router
     */
    get basename(): RouterInit["basename"];
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Return the future config for the router
     */
    get future(): FutureConfig;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Return the current state of the router
     */
    get state(): RouterState;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Return the routes for this router instance
     */
    get routes(): AgnosticDataRouteObject[];
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Return the window associated with the router
     */
    get window(): RouterInit["window"];
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Initialize the router, including adding history listeners and kicking off
     * initial data fetches.  Returns a function to cleanup listeners and abort
     * any in-progress loads
     */
    initialize(): Router;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Subscribe to router.state updates
     *
     * @param fn function to call with the new state
     */
    subscribe(fn: RouterSubscriber): () => void;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Enable scroll restoration behavior in the router
     *
     * @param savedScrollPositions Object that will manage positions, in case
     *                             it's being restored from sessionStorage
     * @param getScrollPosition    Function to get the active Y scroll position
     * @param getKey               Function to get the key to use for restoration
     */
    enableScrollRestoration(savedScrollPositions: Record<string, number>, getScrollPosition: GetScrollPositionFunction, getKey?: GetScrollRestorationKeyFunction): () => void;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Navigate forward/backward in the history stack
     * @param to Delta to move in the history stack
     */
    navigate(to: number): Promise<void>;
    /**
     * Navigate to the given path
     * @param to Path to navigate to
     * @param opts Navigation options (method, submission, etc.)
     */
    navigate(to: To | null, opts?: RouterNavigateOptions): Promise<void>;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Trigger a fetcher load/submission
     *
     * @param key     Fetcher key
     * @param routeId Route that owns the fetcher
     * @param href    href to fetch
     * @param opts    Fetcher options, (method, submission, etc.)
     */
    fetch(key: string, routeId: string, href: string | null, opts?: RouterFetchOptions): Promise<void>;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Trigger a revalidation of all current route loaders and fetcher loads
     */
    revalidate(): Promise<void>;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Utility function to create an href for the given location
     * @param location
     */
    createHref(location: Location | URL): string;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Utility function to URL encode a destination path according to the internal
     * history implementation
     * @param to
     */
    encodeLocation(to: To): Path;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Get/create a fetcher for the given key
     * @param key
     */
    getFetcher<TData = any>(key: string): Fetcher<TData>;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Delete the fetcher for a given key
     * @param key
     */
    deleteFetcher(key: string): void;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Cleanup listeners and abort any in-progress loads
     */
    dispose(): void;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Get a navigation blocker
     * @param key The identifier for the blocker
     * @param fn The blocker function implementation
     */
    getBlocker(key: string, fn: BlockerFunction): Blocker;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Delete a navigation blocker
     * @param key The identifier for the blocker
     */
    deleteBlocker(key: string): void;
    /**
     * @private
     * PRIVATE DO NOT USE
     *
     * Patch additional children routes into an existing parent route
     * @param routeId The parent route id or a callback function accepting `patch`
     *                to perform batch patching
     * @param children The additional children routes
     */
    patchRoutes(routeId: string | null, children: AgnosticRouteObject[]): void;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * HMR needs to pass in-flight route updates to React Router
     * TODO: Replace this with granular route update APIs (addRoute, updateRoute, deleteRoute)
     */
    _internalSetRoutes(routes: AgnosticRouteObject[]): void;
    /**
     * @private
     * PRIVATE - DO NOT USE
     *
     * Internal fetch AbortControllers accessed by unit tests
     */
    _internalFetchControllers: Map<string, AbortController>;
}
/**
 * State maintained internally by the router.  During a navigation, all states
 * reflect the "old" location unless otherwise noted.
 */
interface RouterState {
    /**
     * The action of the most recent navigation
     */
    historyAction: Action;
    /**
     * The current location reflected by the router
     */
    location: Location;
    /**
     * The current set of route matches
     */
    matches: AgnosticDataRouteMatch[];
    /**
     * Tracks whether we've completed our initial data load
     */
    initialized: boolean;
    /**
     * Current scroll position we should start at for a new view
     *  - number -> scroll position to restore to
     *  - false -> do not restore scroll at all (used during submissions)
     *  - null -> don't have a saved position, scroll to hash or top of page
     */
    restoreScrollPosition: number | false | null;
    /**
     * Indicate whether this navigation should skip resetting the scroll position
     * if we are unable to restore the scroll position
     */
    preventScrollReset: boolean;
    /**
     * Tracks the state of the current navigation
     */
    navigation: Navigation;
    /**
     * Tracks any in-progress revalidations
     */
    revalidation: RevalidationState;
    /**
     * Data from the loaders for the current matches
     */
    loaderData: RouteData;
    /**
     * Data from the action for the current matches
     */
    actionData: RouteData | null;
    /**
     * Errors caught from loaders for the current matches
     */
    errors: RouteData | null;
    /**
     * Map of current fetchers
     */
    fetchers: Map<string, Fetcher>;
    /**
     * Map of current blockers
     */
    blockers: Map<string, Blocker>;
}
/**
 * Data that can be passed into hydrate a Router from SSR
 */
type HydrationState = Partial<Pick<RouterState, "loaderData" | "actionData" | "errors">>;
/**
 * Future flags to toggle new feature behavior
 */
interface FutureConfig {
}
/**
 * Initialization options for createRouter
 */
interface RouterInit {
    routes: AgnosticRouteObject[];
    history: History;
    basename?: string;
    mapRouteProperties?: MapRoutePropertiesFunction;
    future?: Partial<FutureConfig>;
    hydrationData?: HydrationState;
    window?: Window;
    dataStrategy?: DataStrategyFunction;
    patchRoutesOnNavigation?: AgnosticPatchRoutesOnNavigationFunction;
}
/**
 * State returned from a server-side query() call
 */
interface StaticHandlerContext {
    basename: Router["basename"];
    location: RouterState["location"];
    matches: RouterState["matches"];
    loaderData: RouterState["loaderData"];
    actionData: RouterState["actionData"];
    errors: RouterState["errors"];
    statusCode: number;
    loaderHeaders: Record<string, Headers>;
    actionHeaders: Record<string, Headers>;
    _deepestRenderedBoundaryId?: string | null;
}
/**
 * A StaticHandler instance manages a singular SSR navigation/fetch event
 */
interface StaticHandler {
    dataRoutes: AgnosticDataRouteObject[];
    query(request: Request, opts?: {
        requestContext?: unknown;
        skipLoaderErrorBubbling?: boolean;
        dataStrategy?: DataStrategyFunction;
    }): Promise<StaticHandlerContext | Response>;
    queryRoute(request: Request, opts?: {
        routeId?: string;
        requestContext?: unknown;
        dataStrategy?: DataStrategyFunction;
    }): Promise<any>;
}
type ViewTransitionOpts = {
    currentLocation: Location;
    nextLocation: Location;
};
/**
 * Subscriber function signature for changes to router state
 */
interface RouterSubscriber {
    (state: RouterState, opts: {
        deletedFetchers: string[];
        viewTransitionOpts?: ViewTransitionOpts;
        flushSync: boolean;
    }): void;
}
/**
 * Function signature for determining the key to be used in scroll restoration
 * for a given location
 */
interface GetScrollRestorationKeyFunction {
    (location: Location, matches: UIMatch[]): string | null;
}
/**
 * Function signature for determining the current scroll position
 */
interface GetScrollPositionFunction {
    (): number;
}
/**
  - "route": relative to the route hierarchy so `..` means remove all segments of the current route even if it has many. For example, a `route("posts/:id")` would have both `:id` and `posts` removed from the url.
  - "path": relative to the pathname so `..` means remove one segment of the pathname. For example, a `route("posts/:id")` would have only `:id` removed from the url.
 */
type RelativeRoutingType = "route" | "path";
type BaseNavigateOrFetchOptions = {
    preventScrollReset?: boolean;
    relative?: RelativeRoutingType;
    flushSync?: boolean;
};
type BaseNavigateOptions = BaseNavigateOrFetchOptions & {
    replace?: boolean;
    state?: any;
    fromRouteId?: string;
    viewTransition?: boolean;
};
type BaseSubmissionOptions = {
    formMethod?: HTMLFormMethod;
    formEncType?: FormEncType;
} & ({
    formData: FormData;
    body?: undefined;
} | {
    formData?: undefined;
    body: any;
});
/**
 * Options for a navigate() call for a normal (non-submission) navigation
 */
type LinkNavigateOptions = BaseNavigateOptions;
/**
 * Options for a navigate() call for a submission navigation
 */
type SubmissionNavigateOptions = BaseNavigateOptions & BaseSubmissionOptions;
/**
 * Options to pass to navigate() for a navigation
 */
type RouterNavigateOptions = LinkNavigateOptions | SubmissionNavigateOptions;
/**
 * Options for a fetch() load
 */
type LoadFetchOptions = BaseNavigateOrFetchOptions;
/**
 * Options for a fetch() submission
 */
type SubmitFetchOptions = BaseNavigateOrFetchOptions & BaseSubmissionOptions;
/**
 * Options to pass to fetch()
 */
type RouterFetchOptions = LoadFetchOptions | SubmitFetchOptions;
/**
 * Potential states for state.navigation
 */
type NavigationStates = {
    Idle: {
        state: "idle";
        location: undefined;
        formMethod: undefined;
        formAction: undefined;
        formEncType: undefined;
        formData: undefined;
        json: undefined;
        text: undefined;
    };
    Loading: {
        state: "loading";
        location: Location;
        formMethod: Submission["formMethod"] | undefined;
        formAction: Submission["formAction"] | undefined;
        formEncType: Submission["formEncType"] | undefined;
        formData: Submission["formData"] | undefined;
        json: Submission["json"] | undefined;
        text: Submission["text"] | undefined;
    };
    Submitting: {
        state: "submitting";
        location: Location;
        formMethod: Submission["formMethod"];
        formAction: Submission["formAction"];
        formEncType: Submission["formEncType"];
        formData: Submission["formData"];
        json: Submission["json"];
        text: Submission["text"];
    };
};
type Navigation = NavigationStates[keyof NavigationStates];
type RevalidationState = "idle" | "loading";
/**
 * Potential states for fetchers
 */
type FetcherStates<TData = any> = {
    /**
     * The fetcher is not calling a loader or action
     *
     * ```tsx
     * fetcher.state === "idle"
     * ```
     */
    Idle: {
        state: "idle";
        formMethod: undefined;
        formAction: undefined;
        formEncType: undefined;
        text: undefined;
        formData: undefined;
        json: undefined;
        /**
         * If the fetcher has never been called, this will be undefined.
         */
        data: TData | undefined;
    };
    /**
     * The fetcher is loading data from a {@link LoaderFunction | loader} from a
     * call to {@link FetcherWithComponents.load | `fetcher.load`}.
     *
     * ```tsx
     * // somewhere
     * <button onClick={() => fetcher.load("/some/route") }>Load</button>
     *
     * // the state will update
     * fetcher.state === "loading"
     * ```
     */
    Loading: {
        state: "loading";
        formMethod: Submission["formMethod"] | undefined;
        formAction: Submission["formAction"] | undefined;
        formEncType: Submission["formEncType"] | undefined;
        text: Submission["text"] | undefined;
        formData: Submission["formData"] | undefined;
        json: Submission["json"] | undefined;
        data: TData | undefined;
    };
    /**
      The fetcher is submitting to a {@link LoaderFunction} (GET) or {@link ActionFunction} (POST) from a {@link FetcherWithComponents.Form | `fetcher.Form`} or {@link FetcherWithComponents.submit | `fetcher.submit`}.
  
      ```tsx
      // somewhere
      <input
        onChange={e => {
          fetcher.submit(event.currentTarget.form, { method: "post" });
        }}
      />
  
      // the state will update
      fetcher.state === "submitting"
  
      // and formData will be available
      fetcher.formData
      ```
     */
    Submitting: {
        state: "submitting";
        formMethod: Submission["formMethod"];
        formAction: Submission["formAction"];
        formEncType: Submission["formEncType"];
        text: Submission["text"];
        formData: Submission["formData"];
        json: Submission["json"];
        data: TData | undefined;
    };
};
type Fetcher<TData = any> = FetcherStates<TData>[keyof FetcherStates<TData>];
interface BlockerBlocked {
    state: "blocked";
    reset(): void;
    proceed(): void;
    location: Location;
}
interface BlockerUnblocked {
    state: "unblocked";
    reset: undefined;
    proceed: undefined;
    location: undefined;
}
interface BlockerProceeding {
    state: "proceeding";
    reset: undefined;
    proceed: undefined;
    location: Location;
}
type Blocker = BlockerUnblocked | BlockerBlocked | BlockerProceeding;
type BlockerFunction = (args: {
    currentLocation: Location;
    nextLocation: Location;
    historyAction: Action;
}) => boolean;
declare const IDLE_NAVIGATION: NavigationStates["Idle"];
declare const IDLE_FETCHER: FetcherStates["Idle"];
declare const IDLE_BLOCKER: BlockerUnblocked;
/**
 * Create a router and listen to history POP navigations
 */
declare function createRouter(init: RouterInit): Router;
interface CreateStaticHandlerOptions {
    basename?: string;
    mapRouteProperties?: MapRoutePropertiesFunction;
    future?: {};
}

interface IndexRouteObject {
    caseSensitive?: AgnosticIndexRouteObject["caseSensitive"];
    path?: AgnosticIndexRouteObject["path"];
    id?: AgnosticIndexRouteObject["id"];
    loader?: AgnosticIndexRouteObject["loader"];
    action?: AgnosticIndexRouteObject["action"];
    hasErrorBoundary?: AgnosticIndexRouteObject["hasErrorBoundary"];
    shouldRevalidate?: AgnosticIndexRouteObject["shouldRevalidate"];
    handle?: AgnosticIndexRouteObject["handle"];
    index: true;
    children?: undefined;
    element?: React.ReactNode | null;
    hydrateFallbackElement?: React.ReactNode | null;
    errorElement?: React.ReactNode | null;
    Component?: React.ComponentType | null;
    HydrateFallback?: React.ComponentType | null;
    ErrorBoundary?: React.ComponentType | null;
    lazy?: LazyRouteFunction<RouteObject>;
}
interface NonIndexRouteObject {
    caseSensitive?: AgnosticNonIndexRouteObject["caseSensitive"];
    path?: AgnosticNonIndexRouteObject["path"];
    id?: AgnosticNonIndexRouteObject["id"];
    loader?: AgnosticNonIndexRouteObject["loader"];
    action?: AgnosticNonIndexRouteObject["action"];
    hasErrorBoundary?: AgnosticNonIndexRouteObject["hasErrorBoundary"];
    shouldRevalidate?: AgnosticNonIndexRouteObject["shouldRevalidate"];
    handle?: AgnosticNonIndexRouteObject["handle"];
    index?: false;
    children?: RouteObject[];
    element?: React.ReactNode | null;
    hydrateFallbackElement?: React.ReactNode | null;
    errorElement?: React.ReactNode | null;
    Component?: React.ComponentType | null;
    HydrateFallback?: React.ComponentType | null;
    ErrorBoundary?: React.ComponentType | null;
    lazy?: LazyRouteFunction<RouteObject>;
}
type RouteObject = IndexRouteObject | NonIndexRouteObject;
type DataRouteObject = RouteObject & {
    children?: DataRouteObject[];
    id: string;
};
interface RouteMatch<ParamKey extends string = string, RouteObjectType extends RouteObject = RouteObject> extends AgnosticRouteMatch<ParamKey, RouteObjectType> {
}
interface DataRouteMatch extends RouteMatch<string, DataRouteObject> {
}
type PatchRoutesOnNavigationFunctionArgs = AgnosticPatchRoutesOnNavigationFunctionArgs<RouteObject, RouteMatch>;
type PatchRoutesOnNavigationFunction = AgnosticPatchRoutesOnNavigationFunction<RouteObject, RouteMatch>;
interface DataRouterContextObject extends Omit<NavigationContextObject, "future"> {
    router: Router;
    staticContext?: StaticHandlerContext;
}
declare const DataRouterContext: React.Context<DataRouterContextObject | null>;
declare const DataRouterStateContext: React.Context<RouterState | null>;
type ViewTransitionContextObject = {
    isTransitioning: false;
} | {
    isTransitioning: true;
    flushSync: boolean;
    currentLocation: Location;
    nextLocation: Location;
};
declare const ViewTransitionContext: React.Context<ViewTransitionContextObject>;
type FetchersContextObject = Map<string, any>;
declare const FetchersContext: React.Context<FetchersContextObject>;
interface NavigateOptions {
    /** Replace the current entry in the history stack instead of pushing a new one */
    replace?: boolean;
    /** Adds persistent client side routing state to the next location */
    state?: any;
    /** If you are using {@link https://api.reactrouter.com/v7/functions/react_router.ScrollRestoration.html <ScrollRestoration>}, prevent the scroll position from being reset to the top of the window when navigating */
    preventScrollReset?: boolean;
    /** Defines the relative path behavior for the link. "route" will use the route hierarchy so ".." will remove all URL segments of the current route pattern while "path" will use the URL path so ".." will remove one URL segment. */
    relative?: RelativeRoutingType;
    /** Wraps the initial state update for this navigation in a {@link https://react.dev/reference/react-dom/flushSync ReactDOM.flushSync} call instead of the default {@link https://react.dev/reference/react/startTransition React.startTransition} */
    flushSync?: boolean;
    /** Enables a {@link https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API View Transition} for this navigation by wrapping the final state update in `document.startViewTransition()`. If you need to apply specific styles for this view transition, you will also need to leverage the {@link https://api.reactrouter.com/v7/functions/react_router.useViewTransitionState.html useViewTransitionState()} hook.  */
    viewTransition?: boolean;
}
/**
 * A Navigator is a "location changer"; it's how you get to different locations.
 *
 * Every history instance conforms to the Navigator interface, but the
 * distinction is useful primarily when it comes to the low-level `<Router>` API
 * where both the location and a navigator must be provided separately in order
 * to avoid "tearing" that may occur in a suspense-enabled app if the action
 * and/or location were to be read directly from the history instance.
 */
interface Navigator {
    createHref: History["createHref"];
    encodeLocation?: History["encodeLocation"];
    go: History["go"];
    push(to: To, state?: any, opts?: NavigateOptions): void;
    replace(to: To, state?: any, opts?: NavigateOptions): void;
}
interface NavigationContextObject {
    basename: string;
    navigator: Navigator;
    static: boolean;
    future: {};
}
declare const NavigationContext: React.Context<NavigationContextObject>;
interface LocationContextObject {
    location: Location;
    navigationType: Action;
}
declare const LocationContext: React.Context<LocationContextObject>;
interface RouteContextObject {
    outlet: React.ReactElement | null;
    matches: RouteMatch[];
    isDataRoute: boolean;
}
declare const RouteContext: React.Context<RouteContextObject>;

type Primitive = null | undefined | string | number | boolean | symbol | bigint;
type LiteralUnion<LiteralType, BaseType extends Primitive> = LiteralType | (BaseType & Record<never, never>);
interface HtmlLinkProps {
    /**
     * Address of the hyperlink
     */
    href?: string;
    /**
     * How the element handles crossorigin requests
     */
    crossOrigin?: "anonymous" | "use-credentials";
    /**
     * Relationship between the document containing the hyperlink and the destination resource
     */
    rel: LiteralUnion<"alternate" | "dns-prefetch" | "icon" | "manifest" | "modulepreload" | "next" | "pingback" | "preconnect" | "prefetch" | "preload" | "prerender" | "search" | "stylesheet", string>;
    /**
     * Applicable media: "screen", "print", "(max-width: 764px)"
     */
    media?: string;
    /**
     * Integrity metadata used in Subresource Integrity checks
     */
    integrity?: string;
    /**
     * Language of the linked resource
     */
    hrefLang?: string;
    /**
     * Hint for the type of the referenced resource
     */
    type?: string;
    /**
     * Referrer policy for fetches initiated by the element
     */
    referrerPolicy?: "" | "no-referrer" | "no-referrer-when-downgrade" | "same-origin" | "origin" | "strict-origin" | "origin-when-cross-origin" | "strict-origin-when-cross-origin" | "unsafe-url";
    /**
     * Sizes of the icons (for rel="icon")
     */
    sizes?: string;
    /**
     * Potential destination for a preload request (for rel="preload" and rel="modulepreload")
     */
    as?: LiteralUnion<"audio" | "audioworklet" | "document" | "embed" | "fetch" | "font" | "frame" | "iframe" | "image" | "manifest" | "object" | "paintworklet" | "report" | "script" | "serviceworker" | "sharedworker" | "style" | "track" | "video" | "worker" | "xslt", string>;
    /**
     * Color to use when customizing a site's icon (for rel="mask-icon")
     */
    color?: string;
    /**
     * Whether the link is disabled
     */
    disabled?: boolean;
    /**
     * The title attribute has special semantics on this element: Title of the link; CSS style sheet set name.
     */
    title?: string;
    /**
     * Images to use in different situations, e.g., high-resolution displays,
     * small monitors, etc. (for rel="preload")
     */
    imageSrcSet?: string;
    /**
     * Image sizes for different page layouts (for rel="preload")
     */
    imageSizes?: string;
}
interface HtmlLinkPreloadImage extends HtmlLinkProps {
    /**
     * Relationship between the document containing the hyperlink and the destination resource
     */
    rel: "preload";
    /**
     * Potential destination for a preload request (for rel="preload" and rel="modulepreload")
     */
    as: "image";
    /**
     * Address of the hyperlink
     */
    href?: string;
    /**
     * Images to use in different situations, e.g., high-resolution displays,
     * small monitors, etc. (for rel="preload")
     */
    imageSrcSet: string;
    /**
     * Image sizes for different page layouts (for rel="preload")
     */
    imageSizes?: string;
}
/**
 * Represents a `<link>` element.
 *
 * WHATWG Specification: https://html.spec.whatwg.org/multipage/semantics.html#the-link-element
 */
type HtmlLinkDescriptor = (HtmlLinkProps & Pick<Required<HtmlLinkProps>, "href">) | (HtmlLinkPreloadImage & Pick<Required<HtmlLinkPreloadImage>, "imageSizes">) | (HtmlLinkPreloadImage & Pick<Required<HtmlLinkPreloadImage>, "href"> & {
    imageSizes?: never;
});
interface PageLinkDescriptor extends Omit<HtmlLinkDescriptor, "href" | "rel" | "type" | "sizes" | "imageSrcSet" | "imageSizes" | "as" | "color" | "title"> {
    /**
     * The absolute path of the page to prefetch.
     */
    page: string;
}
type LinkDescriptor = HtmlLinkDescriptor | PageLinkDescriptor;

interface RouteModules {
    [routeId: string]: RouteModule | undefined;
}
/**
 * The shape of a route module shipped to the client
 */
interface RouteModule {
    clientAction?: ClientActionFunction;
    clientLoader?: ClientLoaderFunction;
    ErrorBoundary?: ErrorBoundaryComponent;
    HydrateFallback?: HydrateFallbackComponent;
    Layout?: LayoutComponent;
    default: RouteComponent;
    handle?: RouteHandle;
    links?: LinksFunction;
    meta?: MetaFunction;
    shouldRevalidate?: ShouldRevalidateFunction;
}
/**
 * The shape of a route module on the server
 */
interface ServerRouteModule extends RouteModule {
    action?: ActionFunction;
    headers?: HeadersFunction | {
        [name: string]: string;
    };
    loader?: LoaderFunction;
}
/**
 * A function that handles data mutations for a route on the client
 */
type ClientActionFunction = (args: ClientActionFunctionArgs) => ReturnType<ActionFunction>;
/**
 * Arguments passed to a route `clientAction` function
 */
type ClientActionFunctionArgs = ActionFunctionArgs<undefined> & {
    serverAction: <T = unknown>() => Promise<SerializeFrom<T>>;
};
/**
 * A function that loads data for a route on the client
 */
type ClientLoaderFunction = ((args: ClientLoaderFunctionArgs) => ReturnType<LoaderFunction>) & {
    hydrate?: boolean;
};
/**
 * Arguments passed to a route `clientLoader` function
 */
type ClientLoaderFunctionArgs = LoaderFunctionArgs<undefined> & {
    serverLoader: <T = unknown>() => Promise<SerializeFrom<T>>;
};
/**
 * ErrorBoundary to display for this route
 */
type ErrorBoundaryComponent = ComponentType;
type HeadersArgs = {
    loaderHeaders: Headers;
    parentHeaders: Headers;
    actionHeaders: Headers;
    errorHeaders: Headers | undefined;
};
/**
 * A function that returns HTTP headers to be used for a route. These headers
 * will be merged with (and take precedence over) headers from parent routes.
 */
interface HeadersFunction {
    (args: HeadersArgs): Headers | HeadersInit;
}
/**
 * `<Route HydrateFallback>` component to render on initial loads
 * when client loaders are present
 */
type HydrateFallbackComponent = ComponentType;
/**
 * Optional, root-only `<Route Layout>` component to wrap the root content in.
 * Useful for defining the <html>/<head>/<body> document shell shared by the
 * Component, HydrateFallback, and ErrorBoundary
 */
type LayoutComponent = ComponentType<{
    children: ReactElement<unknown, ErrorBoundaryComponent | HydrateFallbackComponent | RouteComponent>;
}>;
/**
 * A function that defines `<link>` tags to be inserted into the `<head>` of
 * the document on route transitions.
 *
 * @see https://remix.run/route/meta
 */
interface LinksFunction {
    (): LinkDescriptor[];
}
interface MetaMatch<RouteId extends string = string, Loader extends LoaderFunction | ClientLoaderFunction | unknown = unknown> {
    id: RouteId;
    pathname: DataRouteMatch["pathname"];
    data: Loader extends LoaderFunction | ClientLoaderFunction ? SerializeFrom<Loader> : unknown;
    handle?: RouteHandle;
    params: DataRouteMatch["params"];
    meta: MetaDescriptor[];
    error?: unknown;
}
type MetaMatches<MatchLoaders extends Record<string, LoaderFunction | ClientLoaderFunction | unknown> = Record<string, unknown>> = Array<{
    [K in keyof MatchLoaders]: MetaMatch<Exclude<K, number | symbol>, MatchLoaders[K]>;
}[keyof MatchLoaders]>;
interface MetaArgs<Loader extends LoaderFunction | ClientLoaderFunction | unknown = unknown, MatchLoaders extends Record<string, LoaderFunction | ClientLoaderFunction | unknown> = Record<string, unknown>> {
    data: (Loader extends LoaderFunction | ClientLoaderFunction ? SerializeFrom<Loader> : unknown) | undefined;
    params: Params;
    location: Location;
    matches: MetaMatches<MatchLoaders>;
    error?: unknown;
}
/**
 * A function that returns an array of data objects to use for rendering
 * metadata HTML tags in a route. These tags are not rendered on descendant
 * routes in the route hierarchy. In other words, they will only be rendered on
 * the route in which they are exported.
 *
 * @param Loader - The type of the current route's loader function
 * @param MatchLoaders - Mapping from a parent route's filepath to its loader
 * function type
 *
 * Note that parent route filepaths are relative to the `app/` directory.
 *
 * For example, if this meta function is for `/sales/customers/$customerId`:
 *
 * ```ts
 * // app/root.tsx
 * const loader = () => ({ hello: "world" })
 * export type Loader = typeof loader
 *
 * // app/routes/sales.tsx
 * const loader = () => ({ salesCount: 1074 })
 * export type Loader = typeof loader
 *
 * // app/routes/sales/customers.tsx
 * const loader = () => ({ customerCount: 74 })
 * export type Loader = typeof loader
 *
 * // app/routes/sales/customers/$customersId.tsx
 * import type { Loader as RootLoader } from "../../../root"
 * import type { Loader as SalesLoader } from "../../sales"
 * import type { Loader as CustomersLoader } from "../../sales/customers"
 *
 * const loader = () => ({ name: "Customer name" })
 *
 * const meta: MetaFunction<typeof loader, {
 *  "root": RootLoader,
 *  "routes/sales": SalesLoader,
 *  "routes/sales/customers": CustomersLoader,
 * }> = ({ data, matches }) => {
 *   const { name } = data
 *   //      ^? string
 *   const { customerCount } = matches.find((match) => match.id === "routes/sales/customers").data
 *   //      ^? number
 *   const { salesCount } = matches.find((match) => match.id === "routes/sales").data
 *   //      ^? number
 *   const { hello } = matches.find((match) => match.id === "root").data
 *   //      ^? "world"
 * }
 * ```
 */
interface MetaFunction<Loader extends LoaderFunction | ClientLoaderFunction | unknown = unknown, MatchLoaders extends Record<string, LoaderFunction | ClientLoaderFunction | unknown> = Record<string, unknown>> {
    (args: MetaArgs<Loader, MatchLoaders>): MetaDescriptor[] | undefined;
}
type MetaDescriptor = {
    charSet: "utf-8";
} | {
    title: string;
} | {
    name: string;
    content: string;
} | {
    property: string;
    content: string;
} | {
    httpEquiv: string;
    content: string;
} | {
    "script:ld+json": LdJsonObject;
} | {
    tagName: "meta" | "link";
    [name: string]: string;
} | {
    [name: string]: unknown;
};
type LdJsonObject = {
    [Key in string]: LdJsonValue;
} & {
    [Key in string]?: LdJsonValue | undefined;
};
type LdJsonArray = LdJsonValue[] | readonly LdJsonValue[];
type LdJsonPrimitive = string | number | boolean | null;
type LdJsonValue = LdJsonPrimitive | LdJsonObject | LdJsonArray;
/**
 * A React component that is rendered for a route.
 */
type RouteComponent = ComponentType<{}>;
/**
 * An arbitrary object that is associated with a route.
 *
 * @see https://remix.run/route/handle
 */
type RouteHandle = unknown;

type Serializable = undefined | null | boolean | string | symbol | number | Array<Serializable> | {
    [key: PropertyKey]: Serializable;
} | bigint | Date | URL | RegExp | Error | Map<Serializable, Serializable> | Set<Serializable> | Promise<Serializable>;

/**
 * A brand that can be applied to a type to indicate that it will serialize
 * to a specific type when transported to the client from a loader.
 * Only use this if you have additional serialization/deserialization logic
 * in your application.
 */
type unstable_SerializesTo<T> = {
    unstable__ReactRouter_SerializesTo?: [T];
};

type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;
type IsAny<T> = 0 extends 1 & T ? true : false;
type Func = (...args: any[]) => unknown;
type Pretty<T> = {
    [K in keyof T]: T[K];
} & {};

type Serialize<T> = T extends unstable_SerializesTo<infer To> ? To : T extends Serializable ? T : T extends (...args: any[]) => unknown ? undefined : T extends Promise<infer U> ? Promise<Serialize<U>> : T extends Map<infer K, infer V> ? Map<Serialize<K>, Serialize<V>> : T extends Set<infer U> ? Set<Serialize<U>> : T extends [] ? [] : T extends readonly [infer F, ...infer R] ? [Serialize<F>, ...Serialize<R>] : T extends Array<infer U> ? Array<Serialize<U>> : T extends readonly unknown[] ? readonly Serialize<T[number]>[] : T extends Record<any, any> ? {
    [K in keyof T]: Serialize<T[K]>;
} : undefined;
type VoidToUndefined<T> = Equal<T, void> extends true ? undefined : T;
type DataFrom<T> = IsAny<T> extends true ? undefined : T extends Func ? VoidToUndefined<Awaited<ReturnType<T>>> : undefined;
type ClientData<T> = T extends Response ? never : T extends DataWithResponseInit<infer U> ? U : T;
type ServerData<T> = T extends Response ? never : T extends DataWithResponseInit<infer U> ? Serialize<U> : Serialize<T>;
type ServerDataFrom<T> = ServerData<DataFrom<T>>;
type ClientDataFrom<T> = ClientData<DataFrom<T>>;
type SerializeFrom<T> = T extends (...args: infer Args) => unknown ? Args extends [ClientLoaderFunctionArgs | ClientActionFunctionArgs] ? ClientDataFrom<T> : ServerDataFrom<T> : T;

export { type HTMLFormMethod as $, type ActionFunctionArgs as A, type BlockerFunction as B, type CreateStaticHandlerOptions as C, type DataStrategyFunction as D, type Equal as E, type FutureConfig as F, type GetScrollPositionFunction as G, type HydrationState as H, type InitialEntry as I, type RouterSubscriber as J, type RouterNavigateOptions as K, type LoaderFunctionArgs as L, type MetaFunction as M, type NavigateOptions as N, type RouterFetchOptions as O, type ParamParseKey as P, type DataStrategyFunctionArgs as Q, type RouteModules as R, type ServerRouteModule as S, type To as T, type UIMatch as U, type DataStrategyMatch as V, type DataStrategyResult as W, DataWithResponseInit as X, type ErrorResponse as Y, type FormEncType as Z, type FormMethod as _, type Router as a, type LazyRouteFunction as a0, type PathParam as a1, type RedirectFunction as a2, type ShouldRevalidateFunction as a3, type ShouldRevalidateFunctionArgs as a4, createPath as a5, parsePath as a6, IDLE_NAVIGATION as a7, IDLE_FETCHER as a8, IDLE_BLOCKER as a9, type unstable_SerializesTo as aA, createBrowserHistory as aB, invariant as aC, createRouter as aD, ErrorResponseImpl as aE, DataRouterContext as aF, DataRouterStateContext as aG, FetchersContext as aH, LocationContext as aI, NavigationContext as aJ, RouteContext as aK, ViewTransitionContext as aL, type RouteModule as aM, type History as aN, type ServerDataFrom as aO, type ClientDataFrom as aP, type Func as aQ, type Pretty as aR, data as aa, generatePath as ab, isRouteErrorResponse as ac, matchPath as ad, matchRoutes as ae, redirect as af, redirectDocument as ag, replace as ah, resolvePath as ai, type DataRouteMatch as aj, type DataRouteObject as ak, type Navigator as al, type PatchRoutesOnNavigationFunction as am, type PatchRoutesOnNavigationFunctionArgs as an, type RouteMatch as ao, type ClientActionFunction as ap, type ClientActionFunctionArgs as aq, type ClientLoaderFunction as ar, type ClientLoaderFunctionArgs as as, type HeadersArgs as at, type HeadersFunction as au, type MetaArgs as av, type MetaDescriptor as aw, type PageLinkDescriptor as ax, type HtmlLinkDescriptor as ay, type LinkDescriptor as az, type RouteManifest as b, type RelativeRoutingType as c, type Location as d, Action as e, type Path as f, type PathPattern as g, type PathMatch as h, type Params as i, type RouteObject as j, type Navigation as k, type RevalidationState as l, type SerializeFrom as m, type Blocker as n, type StaticHandlerContext as o, type StaticHandler as p, type IndexRouteObject as q, type LoaderFunction as r, type ActionFunction as s, type LinksFunction as t, type NonIndexRouteObject as u, type RouterState as v, type GetScrollRestorationKeyFunction as w, type Fetcher as x, type NavigationStates as y, type RouterInit as z };
