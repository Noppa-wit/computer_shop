{"version":3,"names":["VALID_OBJECT_CALLEES","VALID_IDENTIFIER_CALLEES","INVALID_METHODS","isValidObjectCallee","val","includes","isValidIdentifierCallee","isInvalidMethod","evaluateTruthy","res","evaluate","confident","value","deopt","path","state","deoptPath","Globals","Map","undefined","Infinity","NaN","evaluateCached","node","seen","has","existing","get","resolved","item","set","_evaluate","isSequenceExpression","exprs","length","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","isTemplateLiteral","evaluateQuasis","quasis","isTaggedTemplateExpression","isMemberExpression","object","name","property","isIdentifier","scope","getBinding","quasi","isConditionalExpression","testResult","isExpressionWrapper","parentPath","isCallExpression","callee","isLiteral","type","key","computed","isReferencedIdentifier","binding","constantViolations","start","end","hasValue","resolve","isUnaryExpression","prefix","operator","argument","isFunction","isClass","arg","isArrayExpression","arr","elems","elem","elemValue","push","isObjectExpression","obj","props","prop","isObjectMethod","isSpreadElement","keyPath","valuePath","isLogicalExpression","wasConfident","left","leftConfident","right","rightConfident","isBinaryExpression","Math","pow","context","func","global","hasOwnProperty","call","args","map","apply","raw","str","i","cooked","expr","String"],"sources":["../../src/path/evaluation.ts"],"sourcesContent":["import type NodePath from \"./index.ts\";\nimport type * as t from \"@babel/types\";\n\n// This file contains Babels metainterpreter that can evaluate static code.\n\nconst VALID_OBJECT_CALLEES = [\"Number\", \"String\", \"Math\"] as const;\nconst VALID_IDENTIFIER_CALLEES = [\n  \"isFinite\",\n  \"isNaN\",\n  \"parseFloat\",\n  \"parseInt\",\n  \"decodeURI\",\n  \"decodeURIComponent\",\n  \"encodeURI\",\n  \"encodeURIComponent\",\n  process.env.BABEL_8_BREAKING ? \"btoa\" : null,\n  process.env.BABEL_8_BREAKING ? \"atob\" : null,\n] as const;\n\nconst INVALID_METHODS = [\"random\"] as const;\n\nfunction isValidObjectCallee(\n  val: string,\n): val is (typeof VALID_OBJECT_CALLEES)[number] {\n  return VALID_OBJECT_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isValidIdentifierCallee(\n  val: string,\n): val is (typeof VALID_IDENTIFIER_CALLEES)[number] {\n  return VALID_IDENTIFIER_CALLEES.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\nfunction isInvalidMethod(val: string): val is (typeof INVALID_METHODS)[number] {\n  return INVALID_METHODS.includes(\n    // @ts-expect-error val is a string\n    val,\n  );\n}\n\n/**\n * Walk the input `node` and statically evaluate if it's truthy.\n *\n * Returning `true` when we're sure that the expression will evaluate to a\n * truthy value, `false` if we're sure that it will evaluate to a falsy\n * value and `undefined` if we aren't sure. Because of this please do not\n * rely on coercion when using this method and check with === if it's false.\n *\n * For example do:\n *\n *   if (t.evaluateTruthy(node) === false) falsyLogic();\n *\n * **AND NOT**\n *\n *   if (!t.evaluateTruthy(node)) falsyLogic();\n *\n */\n\nexport function evaluateTruthy(this: NodePath): boolean {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\ntype State = {\n  confident: boolean;\n  deoptPath: NodePath | null;\n  seen: Map<t.Node, Result>;\n};\n\ntype Result = {\n  resolved: boolean;\n  value?: any;\n};\n/**\n * Deopts the evaluation\n */\nfunction deopt(path: NodePath, state: State) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nconst Globals = new Map([\n  [\"undefined\", undefined],\n  [\"Infinity\", Infinity],\n  [\"NaN\", NaN],\n]);\n\n/**\n * We wrap the _evaluate method so we can track `seen` nodes, we push an item\n * to the map before we actually evaluate it so we can deopt on self recursive\n * nodes such as:\n *\n *   var g = a ? 1 : 2,\n *       a = g * this.foo\n */\nfunction evaluateCached(path: NodePath, state: State): any {\n  const { node } = path;\n  const { seen } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item: Result = { resolved: false };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n    return val;\n  }\n}\n\nfunction _evaluate(path: NodePath, state: State): any {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (\n    path.isStringLiteral() ||\n    path.isNumericLiteral() ||\n    path.isBooleanLiteral()\n  ) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (\n    path.isTaggedTemplateExpression() &&\n    path.get(\"tag\").isMemberExpression()\n  ) {\n    const object = path.get(\"tag.object\") as NodePath;\n    const {\n      // @ts-expect-error todo(flow->ts): possible bug, object is can be any expression and so name might be undefined\n      node: { name },\n    } = object;\n    const property = path.get(\"tag.property\") as NodePath;\n\n    if (\n      object.isIdentifier() &&\n      name === \"String\" &&\n      // todo(flow->ts): was changed from getBinding(name, true)\n      //  should this be hasBinding(name, true) as the binding is never used later?\n      !path.scope.getBinding(name) &&\n      property.isIdentifier() &&\n      property.node.name === \"raw\"\n    ) {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    // TypeCastExpression, ExpressionStatement etc\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  // \"foo\".length, \"foo\"[0]\n  if (\n    path.isMemberExpression() &&\n    !path.parentPath.isCallExpression({ callee: path.node })\n  ) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral()) {\n      // @ts-expect-error todo(flow->ts): instead of typeof - would it be better to check type of ast node?\n      const value = object.node.value;\n      const type = typeof value;\n\n      let key = null;\n      if (path.node.computed) {\n        key = evaluateCached(property, state);\n        if (!state.confident) return;\n      } else if (property.isIdentifier()) {\n        key = property.node.name;\n      }\n      if (\n        (type === \"number\" || type === \"string\") &&\n        key != null &&\n        (typeof key === \"number\" || typeof key === \"string\")\n      ) {\n        return value[key];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding) {\n      if (\n        binding.constantViolations.length > 0 ||\n        path.node.start < binding.path.node.end\n      ) {\n        deopt(binding.path, state);\n        return;\n      }\n      if (binding.hasValue) {\n        return binding.value;\n      }\n    }\n\n    const name = path.node.name;\n    if (Globals.has(name)) {\n      if (!binding) {\n        return Globals.get(name);\n      }\n      deopt(binding.path, state);\n      return;\n    }\n\n    const resolved = path.resolve();\n    if (resolved === path) {\n      deopt(path, state);\n      return;\n    } else {\n      return evaluateCached(resolved, state);\n    }\n  }\n\n  if (path.isUnaryExpression({ prefix: true })) {\n    if (path.node.operator === \"void\") {\n      // we don't need to evaluate the argument to know what this will return\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n    if (\n      path.node.operator === \"typeof\" &&\n      (argument.isFunction() || argument.isClass())\n    ) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n      case \"+\":\n        return +arg;\n      case \"-\":\n        return -arg;\n      case \"~\":\n        return ~arg;\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems: Array<NodePath> = path.get(\"elements\");\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        deopt(elemValue.deopt, state);\n        return;\n      }\n    }\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        deopt(prop, state);\n        return;\n      }\n      const keyPath = prop.get(\"key\");\n      let key;\n      if (prop.node.computed) {\n        key = keyPath.evaluate();\n        if (!key.confident) {\n          deopt(key.deopt, state);\n          return;\n        }\n        key = key.value;\n      } else if (keyPath.isIdentifier()) {\n        key = keyPath.node.name;\n      } else {\n        key = (\n          keyPath.node as t.StringLiteral | t.NumericLiteral | t.BigIntLiteral\n        ).value;\n      }\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n      if (!value.confident) {\n        deopt(value.deopt, state);\n        return;\n      }\n      value = value.value;\n      // @ts-expect-error key is any type\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    // If we are confident that the left side of an && is false, or the left\n    // side of an || is true, we can be confident about the entire expression\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        // TODO consider having a \"truthy type\" that doesn't bail on\n        // left uncertainty but can still evaluate to truthy.\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n\n        return left || right;\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n\n        return left && right;\n      case \"??\":\n        state.confident = leftConfident && (left != null || rightConfident);\n        if (!state.confident) return;\n\n        return left ?? right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n      case \"+\":\n        return left + right;\n      case \"/\":\n        return left / right;\n      case \"*\":\n        return left * right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return left ** right;\n      case \"<\":\n        return left < right;\n      case \">\":\n        return left > right;\n      case \"<=\":\n        return left <= right;\n      case \">=\":\n        return left >= right;\n      case \"==\":\n        return left == right; // eslint-disable-line eqeqeq\n      case \"!=\":\n        return left != right; // eslint-disable-line eqeqeq\n      case \"===\":\n        return left === right;\n      case \"!==\":\n        return left !== right;\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \"^\":\n        return left ^ right;\n      case \"<<\":\n        return left << right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    // Number(1);\n    if (\n      callee.isIdentifier() &&\n      !path.scope.getBinding(callee.node.name) &&\n      (isValidObjectCallee(callee.node.name) ||\n        isValidIdentifierCallee(callee.node.name))\n    ) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      // Math.min(1, 2)\n      if (\n        object.isIdentifier() &&\n        property.isIdentifier() &&\n        isValidObjectCallee(object.node.name) &&\n        !isInvalidMethod(property.node.name)\n      ) {\n        context = global[object.node.name];\n        const key = property.node.name;\n        if (Object.hasOwn(context, key)) {\n          func = context[key as keyof typeof context];\n        }\n      }\n\n      // \"abc\".charCodeAt(4)\n      if (object.isLiteral() && property.isIdentifier()) {\n        // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type (StringLiteral and NumberLiteral)\n        const type = typeof object.node.value;\n        if (type === \"string\" || type === \"number\") {\n          // @ts-expect-error todo(flow->ts): consider checking ast node type instead of value type\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(\n  path: NodePath<t.TaggedTemplateExpression | t.TemplateLiteral>,\n  quasis: Array<any>,\n  state: State,\n  raw = false,\n) {\n  let str = \"\";\n\n  let i = 0;\n  const exprs: Array<NodePath<t.Node>> = path.isTemplateLiteral()\n    ? path.get(\"expressions\")\n    : path.get(\"quasi.expressions\");\n\n  for (const elem of quasis) {\n    // not confident, evaluated an expression we don't like\n    if (!state.confident) break;\n\n    // add on element\n    str += raw ? elem.value.raw : elem.value.cooked;\n\n    // add on interpolated expression if it's present\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\n/**\n * Walk the input `node` and statically evaluate it.\n *\n * Returns an object in the form `{ confident, value, deopt }`. `confident`\n * indicates whether or not we had to drop out of evaluating the expression\n * because of hitting an unknown node that we couldn't confidently find the\n * value of, in which case `deopt` is the path of said node.\n *\n * Example:\n *\n *   t.evaluate(parse(\"5 + 5\")) // { confident: true, value: 10 }\n *   t.evaluate(parse(\"!true\")) // { confident: true, value: false }\n *   t.evaluate(parse(\"foo + foo\")) // { confident: false, value: undefined, deopt: NodePath }\n *\n */\n\nexport function evaluate(this: NodePath): {\n  confident: boolean;\n  value: any;\n  deopt?: NodePath;\n} {\n  const state: State = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map(),\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value,\n  };\n}\n"],"mappings":";;;;;;;AAKA,MAAMA,oBAAoB,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,MAAM,CAAU;AAClE,MAAMC,wBAAwB,GAAG,CAC/B,UAAU,EACV,OAAO,EACP,YAAY,EACZ,UAAU,EACVдид╕д╚д╪дшд°дее(е8еHеXеhеxеИеШеие╕е╚е╪еше°ежж(ж8жHжXжhжxжИжШжиж╕ж╚ж╪жшж°жзз(з8зHзXзhзxзИзШзиз╕з╚з╪зшз°зии(и8иHиXиhиxиИиШиии╕и╚и╪иши°ийй(й8йHйXйhйxйИйШйий╕й╚й╪йшй°йкк(к8кHкXкhкxкИкШкик╕к╚к╪кшк°клл(л8лHлXлxлИлШлил╕л╚л╪лшл°лмм(м8мHмXмhмxмИмШмим╕м╚м╪мшм°мнн(н8нHнXнhнxнИнЁн оо о0о@оPо`оpоАоРоао░о└о╨ороЁо пп п0п@пPп`пpпАпРпап░п└п╨прпЁп p    аа аШмамPпXп   А    XиИоРоШоаоио░о╕о└о╚о╨о   Рp   Xб`бhбpбxбАбИбРбШбабиб░б╕б└б╚б╨б╪брбшбЁбе е(е0е8е@еHеазиз░з╕з└з╚з╨з╪зрзшзЁз°з ииии и(и0и8и@иооо о ░h   шаЁа°а бббб б(б0б8б@бHбPбXб`бhбpбxбАбИбРбШбабиб░б╕б└б╚б╨б╪брбшбЁб°б вввв в(в0в8в@вHвPв м8м └$    вРвШвавив░в н(н0н8н@нHн╚п╨п ╨   ░а╕аPиXи`иhиpиxиАи   р   0л8л@лHлPлXл 0   Hо   @0   Ие@иHиPиXи`иhиpиxиАиИиРиШиаиии░и╕и└и╚и╨и ``   0д8д@дHдPдXд`дhд░з╕з╚з╨зрзшз°з иии(и0и@иHиXи`иpиxиИиРиаиии╕и└и╨и╪иак░к└к╨кркЁк°к ллл p   pбxбАбИб А   Ай   Р8   PвXв`вhвpв0е8е@еHеPеазиз░з╕з└з лл╚л╨л╪лрлшлЁл   аА   ╕г╨гшг дд0дHд`дxдРдид└д╪дЁде е8еPеhеАеШе░е╚ере°еж(ж@жXжpжИжаж╕ж╨жшж зз0зHз`зxзРзиз└з╪зЁзи и8иPиhиАиШи░и╚ири°ий(й@й └$   @зHзPзXз`зhзpзxзАз нннXп`п ╨   Ра░аРеин░н╕н р4   @бPбhбxбаб░б└й╚й╨й╪йрйшйЁй°й кккк к(к0к8к Ё$   (в0в8в@вив╚вшвг(гHгаеше(й       АаИаРаШааа      Рк       рдшдЁд°д еее└е 0H   ИаШаиа╕а╚а╪аша°абб(б8бHбXбhбxбИбШбиб╕б╚б╪бшб°бвв(в8вHвXвhвxв P    иHиPи`иhи╨нрнЁн оо `l   вв@вHвxвАв░в╕вшвЁв г(гXг`гРгШг╚г╨г дд8д@дpдxдид░дрдшде еhнАнШн░н╚нрн°но(о0оHо`оxоРоио└о╪оШп╚п   АА   ░й╕й└й╚й╨й╪йрйшйЁй°й кккк к(к0к8к@кHкPкXк`кhкpкxкАкИкРкШкакик░к╕к└к╚к╨к╪кркшкЁк°к лллл л(л0л8л@лHлPлXл`лhлpлxлАл   РФ   8бШжажиж░ж╕ж└ж8кPкhкАкШк░к╚крк°кл(л@лXлpлИлал╕л╨лшл мм0мHм`мxмРмим└м╪мЁмн н8нPнhнАнШн░н╚нрн°но(о@оXоpоИоао╕о╨ошо пп0пHп`пxпРпип└п╪пЁп   аМ   а а8аPаhаАаШа░а╚ара°аб(б@бXбpбИбаб╕б╨бшб вв0вHв`вxвЁе жжжж(ж0ж8ж@жPжXж`жhжxжАжИжРжажиж░ж╕ж╚ж╨ж╪жржал░л0н8н@нHнPнXн`нhнpнxнАн   ░$   иж0оPоhоАоШо░о╚оро°оп(п@пXп └p   °з ииии и(и0и8и@и о(о0о8о@оHоPоXо`оhоpоxоАоИоРоШоаоио░о╕о└о╚о╨о╪орошоЁо°о пппп п(п0п8п@пHпPпXп`п   ╨D   ааиа░а╕а└а╚а╨а╪арашаЁа°а бббб б(б0б8б@бHбPбXб`бhбpбxбHж   р\   0ж8ж@жHжPжXж`жhжpжxжАжИжРжШжажиж░ж╕ж└ж╚ж╨ж╪жржшж╕к└к╚к нн н0н8нHнPн`нxнАнРнШнин░н        РаШа░а╕а╨а╪аЁа°аб8бHбXб     РеШеае`йhйpйxйАйШйий└й╨й @0   шбЁб°б вввв в(в0в╨о╪ороЁо°о ппп п   p(   @аHаPа`лhлpлАлИлРлалил░л└л╚л╨л   А   рбшбЁб@вHв╨п╪прпшпЁп Рl   0ж8ж@жHжPжxжИжаж░жPиXи`иhиpиШиии└и╨иpкxкАкИкРк╕к└к╚кркЁкxмИмРмШмамим░м└м╪м ннШоио░о╕о└о╚о╨оро°о п0п а`   ╕а╚а╨а╪арашаЁа бб@бPб╪вшвЁв°в ггг г8г`гpгhеpеxе░е╕е└е╚еЁе жз(з╚и╨и╪иришиЁи°ийй й(й  0   pдxдИд░д└д╨дрдЁд ее е0е@еPе`еpеАе@мXмpм  $   Ёаб0баб@гие╨е°е(ж`лxлалио╨о 0   Hл`лРлhоpоxо @h   ра°а бг0гPгАдад░д╨дрд°де(е0е@еHеXеpеИеаеие╕е└е╨е╪еше ии и0и@иPи`иpиАиРиаи░иИйай╕йрйк кHкpн   P,   ░м╕м└м╚м╨м╪мрмшмЁм°м нннн н(н0н8н `   аб└е а   еий╚й   ╨   0б@бPб   Ё   рзшзЁз°з ииии  X   PаXа`аhаpаxаАаИаЁв°в г@гHгPгАдИдРд╨д╪дрд╨к╪кркшкЁклл л(л0лPлXл`лhлpлРлШлалил░л  p   Ёий й8йPйXйhйpйАйИйШйай░й╕й╚й╨й°йк(к@кXкpкxкИкРкакик╕к└к╨к╪кшкЁкл0лHл`лxлРлШлил░л└л╚л╪лрлЁл°лмм8м   08   └в╚в╨в╪врвшвЁв°в гггг г(г0г8г@гHгPгXг`гhгpгxг а0   РвШвав╨в╪врвгг гагигргшг д(д8д╕д°д8е   └Ф  ╪брбшбЁб°б вввв в(в0в8в@вHвPвXв`вhвpвxвАвИвРвШвавив░в╕в└в╚в╨в╪врвшвЁв°в гггг г(г0г8г@гHгPгXг`гhгpгxгАгИгРгШгагиг░г╕г└г╚г╨г╪гргшгЁг°г дддд д(д0д8д@дHдPдXд`дhдpдxдАдИдРдШдадид░д╕д└д╚д╨д╪дрдшдЁд°д ееее е(е0е8е@еHеPеXе`еhеpеxеАеИеРеШеаеие░е╕е└е╚е╨е╪ерешеЁе°е жжжж ж(ж0ж8ж@жHжPжXж`жhжpжxжАжИжРжШжажиж░ж╕ж└ж╚ж╨ж╪жржшжЁж°ж зззз з(з0з8з@зHзPзXз`зhзpзxзАзИзРзШзазиз░з╕з└з╚з╨з╪зрзшзЁз°з ииии и(и0и8и@иHиPиXи`иhиpиxиАиИиРиШиаиии░и╕и└и╚и╨и╪иришиЁи°и йййй й(й0й8й@йHйPйXй`йhйpйxйАйИйРйШйайий░й╕й└й╚й╨й╪йрйшйЁй°й кккк к(к0к8к@кHкPкXк`кhкpкxкАкИкРкШкакик░к╕к└к╚к╨к╪кркшкЁк°к лллл л(л0л8л@лHлPлXл`лhлpлxлАлИлРлШлалил░л╕л└л╚л╨л╪лрлшлЁл°л мммм м(м0м8м@мHмPмXм`мhмpмxмАмИмРмШмамим░м╕м└м╚м╨м╪мрмшмЁм°м нннн н(н0н8н@нHнPнXн`нhнpнxнАнИнРнШнанин░н╕н└н╚н╨н╪нрншнЁн°н оооо о(о0о8о@оHоPоXо`оhоpоxоАоИоРоШоаоио░о╕о└о╚о╨о╪орошоЁо°о пппп п(п0п8п@пHпPпXп`пhпpпxпАпИпРпШпапип░п╕п└п╚п╨п╪прпшпЁп°п   ╨└   аааа а(а0а8а@аHаPаXа`аhаpаxаАаИаРаШаааиа░а╕а└а╚а╨а╪арашаЁа°а бббб б(б0б8б@бHбPбXб`бhбpбxбАбИбРбШбабиб░б╕б└б╚б╨б╪брбшбЁб°б вввв в(в0в8в@вHвPвXв`вhвpвxвАвИвРвШвавив░в╕в└в╚в╨в╪врвшвЁв°в гггг г(г0г8г@гHгPгXг`гhгpгxгАгИгРгШгагиг░г╕г└г╚г╨г╪гргшгЁг°г дддд д(д0д8д@дHдPдXд`дhдpдxдАдИдРдШдадид░д╕д└д╚д╨д╪дрдшдЁд°д ееее е(е0е8е@еHеPеXе`еhеpеxеАеИеРеШеаеие░е╕е└е╚е╨е╪ерешеЁе°е жжжж ж(ж0ж8ж@жHжPжXж`жhжpжxжАжИжРжШжажиж░ж╕ж└ж╚ж╨ж       └в╚в@гPгаг╕г└г╪г 0   рбшбЁб°б@вHвPвXв`вhвpвxвАвИвРвШвавив░в    @   РмЁм°м нннн н(н0н8н@нHнPнXн`нhнpнxнАнИнРнШнанин░н╕н   0Ь   л л(л0лXлpлил└л╚л╨лшл м(м@мpмИмРмШм╕м╨м╪м нн нHн`нhн░н╚н╨нЁн°н оооо о(о0о8о@оPоXо`оhоpоxоАоИоРоШоаоио░о╕о└о╚о╨о╪орошоЁо°о пппп п(п0п8п@пHпPп @(  ааиа░а╕а└а╚а╨а╪арашаЁа°а бббб б(б0б@бXбpбРбШбабиб░б╕б└б╚б╨б╪брбшбЁб°б вввв в(в0в8в@вHвPвXв`вhвpвxвАвИвРвШвавив░в╕в└в╚в╨в╪врвшвЁв°в гггг г(г0г8г@гHгPгXг`гhгpгxгШгагд0д8дад╚д╨д8еhеpе╪ежжxжиж░жзHзPз╕зшзЁзXиИиРи°и(й0йШй╚й╨й8кhкpк╪кллxлил░лмHмPм╕мшмЁмXнИнРн°н(о0оШо╚о╨о8пhпpп╪п Pа   ааxаааиаб8б@биб╨б╪б@вhвpв╪вггxгиг░гдHдPд╕дшдЁдXеИеРе°е ж(жРж└ж╚ж0зhзpз╪з ииpиаииий@йHйрйшйPкАкИкЁк л(лРл╚л╨л8мpмxмрмн нИн└н╚н0оhоpо╪оппАп╕п└п `Ь   (а`аhа╨аббxб░б╕б вPвXв└вЁв°в`гРгШг д0д8дад╨д╪д@еpеxережжАж░ж╕ж зPзXз└зшзЁзXиАиИиЁий йИй░й╕й кHкPкшкЁкXлpлxлрлмм░м╕м нPнXн╪нрнHоxоАоппАп░п╕п pд    аPаXа└ашаЁаXбИбРб°б(в0вШв└в╚в0г`гhг╨г ддpдадиде@еHе░ерешеPжxжАжшжз зИз╕з└з(иXи`и╚и°и йhйШйайк8к@кик╪кркHлxлАлшлм мИм╕м└м(нXн`н╚н°н оhоШоаоп8п@пип╪прп А|   HаxаАашаб бИб└б╚б0вhвpв╪вггxгРгШгагиг░г╕г└г╚г╨г╪гргшгЁг°г дддд д(д0д8д@дHдPдXд`дhдpдxдАдИдРдШдадид░д╕д└д╚д╨д   Р$   └к╚к╨к╪кркшкЁк°к лллл л(л └p   └в╚в╨в╪врвшвЁв°в гггг г(г0г8г@гHгPгаоио░о╕о└о╚о╨о╪орошоЁо°о пппп п(п0п8п@пHпPпXп`пhпpпxпАпИпРпШп   р   `лhлpлxлАл   Ё   Ил   ╨   HлhлИлАпИпШп р    8а@аPаааиа╕а@бHбXб└б╚б╪б Ё0    ккккШкакик░к╕к└к╚к╨к╪кркшкЁк°к ллл  \   ее е(е0е8е@еHеPеXе`еhеpеxеАеИеРеШеаеие░е╕е└е╚е╨е╪ерешеЁе°е жжжж ж(ж0ж8ж@жHжPжXж    ╨е╪ерешеЁе°е жж @   Hз(н P(  шг°гдд(д8дHдXдhдxдИдШдид╕д╚д╪дшд°дее(е8еHеXеhеxеИеШеие╕е╚е╪еше°ежж(ж8жHжXжШйий╕й╚й╪йшй°йкк(к8кHкXкhкxкИкШкик╕к╚к╪кшк°клл(л8лHлXлhлxлИлШлил╕л╚л╪лшл°лмм(м8мHмXмhмxмИмШмим╕м╚м╪мшм°мнн(н8нHнXнhнxнИнШнин╕н╚н╪ншн°ноо(о8оHоXоhоxоИоШоио╕о╚о╪ошо°опп(п8пHпXпhпxпИпШпип╕п╚п╪пшп°п   `р   аа(а8аHаXаhаxаИаШаиа╕а╚а╪аша°абб(б8бHбXбhбxбИбШбиб╕б╚б╪бшб°бвв(в8вHвXвhвxвИвШвив╕в╚в╪вшв°вгг(г8гHгXгhгxгИгШгиг╕г╚г╪гшг°гдд(д8дHдXдhдxдИдШдид╕д╚д╪дшд°дее(е8еHеXеhеxеИеШеие╕е╚е╪еше°ежж(ж8жHжXжhжxжИжШжиж   ░4   └н╚н╨н╪нрншнЁн°н оооо о(о0о8о@оHоPоXо╨п   └0   из░з╕з└з╚з╨з╪зрзшзЁз°з ииЁк`нpнxнИнРнан рL   (й0й8й@йHйPй@кXкрнЁн оо о0о@оPо`оpоАоРоао░о└о╨ороЁо пп п0п@пPпpпАп  P   xлИлШлил╕л╚л╪лшл°лмм(м8мHмXмhмxмИмШмим╕м╚м╪мшм°мнн(н8нHнXнhнxнИнШн   @   Риии└и╪иЁий й8йPйhйАйШй░й╚йрй°йк(к@кXкpкИкак╕к╨кшк лл 0а  АжИжШжаж░ж╕ж╚ж╨жржшж°ж ззз(з0з@зHзXз`зpзxзИзРзазиз╕з└з╨з╪зшзЁз иии и0и8иHиPи`иhиxиАиРиШиии░и└и╚и╪ириЁи°ийй й(й8й@йPйXйhйpйАйИйШйай░й╕й╚й╨йрйшй°й ккк(к0к@кHкXк`кpкxкИкРкакик╕к└к╨к╪кшкЁк ллл л0л8лHлPл`лhлxлАлРлШлил░л└л╚л╪лрлЁл°лмм м(м8м@мPмXмhмpмАмИмШмам░м╕м╚м╨мрмшм°м ннн(н0н@нHнXн`нpнxнИнРнанин╕н└н╨н╪ншнЁн ооо о0о8оHоPо`оhоxоАоРоШоио░о└о╚о╪ороЁо°опп п(п8п@пPпXпhпpпАпИпШпап░п╕п╚п╨прпшп°п   @┤   ааа(а0а@аHаXа`аpаxаИаРаааиа╕а└а╨а╪ашаЁа ббб б0б8бHбPб`бhбxбАбРбШбиб░б└б╚б╪брбЁб°бвв в(в8в@вPвXвhвpвАвИвШвав░в╕в╚в╨врвшв°в ггг(г0г@гHгXг`гpгxгИгРгагиг╕г└г╨г╪гшгЁг ддд д0д8дHдPд`дhдxдАдРдШдид░д└д╚д╪дрдЁд°дее е(е8е@еPеXеhеpеАеИеШеае░е╕е╚е╨ереше°е жжж(ж0ж@жHжXж`жpжxжИжРжажиж╕ж└ж╨ж╪жшжЁж ззз з0з8зHзPз`зhзxзАзРзШзиз░з└з╚з╪зрзЁз°зии и(и8и@иPиXиhиpиАиИиШиаи░и╕и╚и╨ириши°и ййй(й0й@йHйXй`йpйxйИйРйайий╕й└й╨й╪йшйЁй ккк к0к8кHкPк`кhкxкАкРкШкик░к└к╚к╪кркЁк°клл л(л8л@лPлXлhлpлАлИлШлал░л╕л╚л╨лрлшл°л ммм(м0м@мHмXм`мpмxмИмРмамим╕м└м╨м╪мшмЁм ннн н0н8нHнPн`нhнxнАнРнШнин░н└н╚н╪нрнЁн°ноо о(о8о@оPоXоhоpоАоИоШоао░о╕о╚о╨орошо°о ппп(п0п@пHпXп`пpпxпИпРпапип╕п└п╨п╪пшпЁп   P┤   ааа а0а8аHаPа`аhаxаАаРаШаиа░а└а╚а╪араЁа°абб б(б8б@бPбXбhбpбАбИбШбаб░б╕б╚б╨брбшб°б ввв(в0в@вHвXв`вpвxвИвРвавив╕в└в╨в╪вшвЁв ггг г0г8гHгPг`гhгxгАгРгШгиг░г└г╚г╪гргЁг°гдд д(д8д@дPдXдhдpдАдИдШдад░д╕д╚д╨дрдшд°д еее(е0е@еHеXе`еpеxеИеРеаеие╕е└е╨е╪ешеЁе жжж ж0ж8жHжPж`жhжxжАжРжШжиж░ж└ж╚ж╪жржЁж°жзз з(з8з@зPзXзhзpзАзИзШзаз░з╕з╚з╨зрзшз°з иии(и0и@иHиXи`иpиxиИиРиаиии╕и└и╨и╪ишиЁи ййй й0й8йHйPй`йhйxйАйРйШйий░й└й╚й╪йрйЁй°йкк к(к8к@кPкXкhкpкАкИкШкак░к╕к╚к╨кркшк°к ллл(л0л@лHлXл`лpлxлИлРлалил╕л└л╨л╪лшлЁл ммм м0м8мHмPм`мhмxмАмРмШмим░м└м╚м╪мрмЁм°мнн н(н8н@нPнXнhнpнАнИнШнан░н╕н╚н╨нрншн°н ооо(о0о@оHоXо`оpоxоИоРоаоио╕о└о╨о╪ошоЁо ппп п0п8пHпPп`пhпxпАпРпШпип░п└п╚п╪прпЁп°п `Ш  аа а(а8а@аPаXаhаpаАаИаШааа░а╕а╚а╨араша°а ббб(б0б@бHбXб`бpбxбИбРбабиб╕б└б╨б╪бшбЁб ввв в0в8вHвPв`вhвxвАвРвШвив░в└в╚в╪врвЁв°вгг г(г8г@гPгXгhгpгАгИгШгаг░г╕г╚г╨гргшг°г ддд(д0д@дHдXд`дpдxдИдРдадид╕д└д╨д╪дшдЁд еее е0е8еHеPе`еhеxеАеРеШеие░е└е╚е╪ереЁе°ежж ж(ж8ж@жPжXжhжpжАжИжШжаж░ж╕ж╚ж╨жржшж°ж ззз(з0з@зHзXз`зpзxзИзРзазиз╕з└з╨з╪зшзЁз иии и0и8иHиPи`иhиxиАиРиШиии░и└и╚и╪ириЁи°ийй й(й8й@йPй   А╠   ╨дрдшд°д(еИеРеШеие╪еHжPжXжhжШж°ж зззHз░з╕з└з╚з╪зиАиИиРиШиаиии╕и╪ишиpйxйАйИйРйШйайий░й└й╚й╪й°йкpкАкИкШк╚к(л0л8лHлxл ммм м(м8мXмhмрмЁм°мн8нШнанин╕ншн`оhоpоxоАоаоио░о╕о└о╨о╪ошоппpпxпИпип╕п   РЁ   ░а└а╚а╪абhбpбxбИб╕бв в(в8вhв╚в╨в╪вшвгxгАгИгШг╚г(д0д8дHдxдрдшдЁд°д еееHе░е╕е└е╚е╪ежhжpжxжИж╕жз з(з8зhз╚з╨з╪зшзиxиАиИиШи╚и(й0й8йHйxйрйшйЁй°йк8кШкакик╕кшкHлPлXлhлШл°л мммHмим░м╕м╚м°м`нhнpнxнИн╕но о(о8оhо╚о╨о╪ошопxпАпИпШп╚п а(  0а8а@аPаXаhаИаШа°а бббHб░б╕б└б╨б╪бшбввxвАвИвШв╚в(г0г8гHгxг дддд(дXд╚д╨д╪дшдеxеАеИеШе╚е(ж0ж8жHжxжЁж°ж ззз з(зPзXз`зhзpзАзИз░з╕з└з╚з╨зрзшзЁз°зи(и8иHиРиШиии╚и╪иши0й8йHйhйxйИй8к@кHкXкИкшкЁк°кл8лШлалил╕лшлHмPмXмhмШмннн(нXн╕н└н╚н╪ноpоxоАоИоРоШоаоио░о╕о└о╚о╨орошо°о(пИпРпШпип╪п   ░4  `аhаpаxаАаИаРаШааа╨а╪арашаЁа°а ббб@бHбPбXб`бhбpбxбАб░б╕б└б╚б╨брбшбЁб°бв(в8вHвРвШвив╚в╪вшв0г8гHгhгxгИг╨г╪гшгдд(д└д╨д╪дшдеРеШеаеие░е└е╚е╪е°ежhжpжxжИж╕жз з(з8зhз ииии и(и0и8и@иHиPиXи`иpиxиИиии╕икк к(к8кhк╚к╨к╪кшклxлАлИлШл╚л(м8м@мHмXмИмрмшм°м8н░н╕н└н╨н╪ншнооxоАоИоШо╚о(п0п8пHпxп╪прпшп°п   └  (а░а╕а└а╚а╨а╪арашаЁа ббб8бHбиб░б╕б╚б°бpвxвАвРвШвив╚в╪вPгXг`гpгxгИгиг╕г@дHдPдXд`дhдxдШдиде е(е8еhе╚е╨е╪ешежxжИжРжШжиж╪ж0з8зHзИз╪зрзшз°з(иИиаи░и╕и╚и°иPйXйhйий°й кккHкик░к╕к╚к°кXл`лhлxлилм м(м8мxм╨м╪мрмшмЁм ннн8нHн░н└н╚н╪ноhоpоxоИо╕о8п@пHпXпИп   ╨(   аааа@аHаPаpаАаИаШа╕а╚а б(б8бXбhб└б╚б╪бвhвpвxвИв╕в0г@гHгXгИгд д(д8дhд╚д╨д╪дшдеИеРеШеие╪е@жHжPжXж`жhжpжАжИжШж╕ж╚ж0з8з@зHзXзИз иии и(и8иXиhириЁи°ий8йШйайий╕йшйPкXк`кpкxкИкик╕к0л8л@лPлXлhлИлШлмм м(м0м8м@мHмPмXм`мhмpмxмИм╕м╚мн н(н8нhн╨н╪нрншнЁн°н оооо о(о0о8о@оHоXоxоИорпшпЁп   р$   ааа8аHа╨а╪араша°а(биб░б╕б╚б°бXв`вhвxвив г(г0г@гHгXгxгИгд8д@дHдXдИдрдшд°д(еаеие░е╕е╚е°еXж`жhжxж╕ж0з8з@зHзPзXз`зhзpзxзАзИзРзШзазиз░з╕з└з╚з╨з╪зрзшзЁз°з ииии и(и8иXиhиpйАйИйШй╚й(к0к8кHкxк╪кркшк°к(лИлРлШлил╪л8м@мHмXмИмЁм°м ннн н(н8нXнhнЁн°н ооо(оHоXо╕о└о╚о╪опpпxпАпРпШпип╚п╪п   Ёь   `аhаpаxаАаРаШаиа╚а╪а`бhбpбАбИбШб╕б╚б(в0в8вHвxвЁв°в ггг(гHгXгргшгЁг ддд8дHд░д└д╚д╪деhеpеxеИе╕е0ж8ж@жPжXжhжИжШжзз з(з0з8з@зHзPзXзhзИзШзxлАлИлШл╪л@мHмPмXм`мАмИмРмШмам░м╕м╚мшм°мPнXнhнИнШн оооо о0о8оHоhоxо°о пппHп└п╨п╪пшп  8  а╨а╪арашаЁа°а ббб(бHбXбhб ввв(вXв└в╚в╨в╪врвшвЁв°в гггг г(г0г8г@гHгXгxгИгЁг°г дддд д(д0д8д@дHдPдXд`дhдpдxдАдРдШдид╚д╪д@еHеPеXе`еhеpеАеИеШе╕е╚е(ж0ж8жHжxжЁж зззHзиз░з╕з╚з°зXи`иhиxиии0й8й@йHйPйXй`йhйpйАйИйШй╕й╚йАкИкРкШкик╪к8лHлPлXлhлШлЁл°лмHмШмамим╕м°мHнPнXнhнин°н оооHоио░о╕о╚опXп`пhпxпип   (   а(а0а8а@а`аhаpаxаАаРаШаиа╚а╪а0б8бHбhбxбшбЁб°бв8врвшвЁв°в ггг г(г8гXгhгPдXд`дhдpдxдАдРдШдид╚д╪дАеИеРеШеаеие░е╕е└е╚е╨е╪ереЁе°еж(ж8жаж░ж╕ж╚ж°