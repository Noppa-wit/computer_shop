"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.patternLikeCommon = exports.importAttributes = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
var _is = require("../validators/is.js");
var _isValidIdentifier = require("../validators/isValidIdentifier.js");
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
var _helperStringParser = require("@babel/helper-string-parser");
var _index = require("../constants/index.js");
var _utils = require("./utils.js");
const defineType = (0, _utils.defineAliasedType)("Standardized");
defineType("ArrayExpression", {
  fields: {
    elements: {
      validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
    }
  },
  visitor: ["elements"],
  aliases: ["Expression"]
});
defineType("AssignmentExpression", {
  fields: {
    operator: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("string") : Object.assign(function () {
        const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);
        const pattern = (0, _utils.assertOneOf)("=");
        return function (node, key, val) {
          const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
          validator(node, key, val);
        };
      }(), {
        type: "string"
      })
    },
    left: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Expression"]
});
defineType("BinaryExpression", {
  builder: ["operator", "left", "right"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
    },
    left: {
      validate: function () {
        const expression = (0, _utils.assertNodeType)("Expression");
        const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
        const validator = Object.assign(function (node, key, val) {
          const validator = node.operator === "in" ? inOp : expression;
          validator(node, key, val);
        }, {
          oneOfNodeTypes: ["Expression", "PrivateName"]
        });
        return validator;
      }()
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"]
});
defineType("InterpreterDirective", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
defineType("Directive", {
  visitor: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertNodeType)("DirectiveLiteral")
    }
  }
});
defineType("DirectiveLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  }
});
defineType("BlockStatement", {
  builder: ["body", "directives"],
  visitor: ["directives", "body"],
  fields: {
    directives: {
      validate: (0, _utils.arrayOfType)("Directive"),
      default: []
    },
    body: (0, _utils.validateArrayOfType)("Statement")
  },
  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
});
defineType("BreakStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
defineType("CallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments"],
  aliases: ["Expression"],
  fields: Object.assign({
    callee: {
      validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
    },
    arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    }
  }, {
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  })
});
defineType("CatchClause", {
  visitor: ["param", "body"],
  fields: {
    param: {
      validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  },
  aliases: ["Scopable", "BlockParent"]
});
defineType("ConditionalExpression", {
  visitor: ["test", "consequent", "alternate"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    alternate: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  aliases: ["Expression", "Conditional"]
});
defineType("ContinueStatement", {
  visitor: ["label"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    }
  },
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
defineType("DebuggerStatement", {
  aliases: ["Statement"]
});
defineType("DoWhileStatement", {
  builder: ["test", "body"],
  visitor: ["body", "test"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  },
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
});
defineType("EmptyStatement", {
  aliases: ["Statement"]
});
defineType("ExpressionStatement", {
  visitor: ["expression"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  },
  aliases: ["Statement", "ExpressionWrapper"]
});
defineType("File", {
  builder: ["program", "comments", "tokens"],
  visitor: ["program"],
  fields: {
    program: {
      validate: (0, _utils.assertNodeType)("Program")
    },
    comments: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {
        each: {
          oneOfNodeTypes: ["CommentBlock", "CommentLine"]
        }
      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
      optional: true
    },
    tokens: {
      validate: (0, _utils.assertEach)(Object.assign(() => {}, {
        type: "any"
      })),
      optional: true
    }
  }
});
defineType("ForInStatement", {
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: {
    left: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
defineType("ForStatement", {
  visitor: ["init", "test", "update", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
  fields: {
    init: {
      validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
      optional: true
    },
    test: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    update: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
const functionCommon = () => ({
  params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
  generator: {
    default: false
  },
  async: {
    default: false
  }
});
exports.functionCommon = functionCommon;
const functionTypeAnnotationCommon = () => ({
  returnType: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  typeParameters: {
    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
    optional: true
  }
});
exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
const functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
  declare: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  id: {
    validate: (0, _utils.assertNodeType)("Identifier"),
    optional: true
  }
});
exports.functionDeclarationCommon = functionDeclarationCommon;
defineType("FunctionDeclaration", {
  builder: ["id", "params", "body", "generator", "async"],
  visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
  fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    },
    predicate: {
      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
      optional: true
    }
  }),
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
    const identifier = (0, _utils.assertNodeType)("Identifier");
    return function (parent, key, node) {
      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
        identifier(node, "id", node.id);
      }
    };
  }()
});
defineType("FunctionExpression", {
  inherits: "FunctionDeclaration",
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    },
    predicate: {
      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
      optional: true
    }
  })
});
const patternLikeCommon = () => ({
  typeAnnotation: {
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
    optional: true
  },
  optional: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  decorators: {
    validate: (0, _utils.arrayOfType)("Decorator"),
    optional: true
  }
});
exports.patternLikeCommon = patternLikeCommon;
defineType("Identifier", {
  builder: ["name"],
  visitor: ["typeAnnotation", "decorators"],
  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
  fields: Object.assign({}, patternLikeCommon(), {
    name: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
        if (!(0, _isValidIdentifier.default)(val, false)) {
          throw new TypeError(`"${val}" is not a valid identifier name`);
        }
      }, {
        type: "string"
      })) : (0, _utils.assertValueType)("string")
    }
  }),
  validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key, node) {
    const match = /\.(\w+)$/.exec(key);
    if (!match) return;
    const [, parentKey] = match;
    const nonComp = {
      computed: false
    };
    if (parentKey === "property") {
      if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
      if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
    } else if (parentKey === "key") {
      if ((0, _is.default)("Property", parent, nonComp)) return;
      if ((0, _is.default)("Method", parent, nonComp)) return;
    } else if (parentKey === "exported") {
      if ((0, _is.default)("ExportSpecifier", parent)) return;
    } else if (parentKey === "imported") {
      if ((0, _is.default)("ImportSpecifier", parent, {
        imported: node
      })) return;
    } else if (parentKey === "meta") {
      if ((0, _is.default)("MetaProperty", parent, {
        meta: node
      })) return;
    }
    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
      throw new TypeError(`"${node.name}" is not a valid identifier`);
    }
  } : undefined
});
defineType("IfStatement", {
  visitor: ["test", "consequent", "alternate"],
  aliases: ["Statement", "Conditional"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    consequent: {
      validate: (0, _utils.assertNodeType)("Statement")
    },
    alternate: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
defineType("LabeledStatement", {
  visitor: ["label", "body"],
  aliases: ["Statement"],
  fields: {
    label: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    body: {
      validate: (0, _utils.assertNodeType)("Statement")
    }
  }
});
defineType("StringLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
defineType("NumericLiteral", {
  builder: ["value"],
  deprecatedAlias: "NumberLiteral",
  fields: {
    value: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function (node, key, val) {
        if (1 / val < 0 || !Number.isFinite(val)) {
          const error = new Error("NumericLiterals must be non-negative finite numbers. " + `You can use t.valueToNode(${val}) instead.`);
          {}
        }
      }, {
        type: "number"
      }))
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
defineType("NullLiteral", {
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
defineType("BooleanLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("boolean")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
defineType("RegExpLiteral", {
  builder: ["pattern", "flags"],
  deprecatedAlias: "RegexLiteral",
  aliases: ["Expression", "Pureish", "Literal"],
  fields: {
    pattern: {
      validate: (0, _utils.assertValueType)("string")
    },
    flags: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
        const invalid = /[^gimsuy]/.exec(val);
        if (invalid) {
          throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
        }
      }, {
        type: "string"
      })) : (0, _utils.assertValueType)("string"),
      default: ""
    }
  }
});
defineType("LogicalExpression", {
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"],
  fields: {
    operator: {
      validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
    },
    left: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    right: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
defineType("MemberExpression", {
  builder: ["object", "property", "computed", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : [])],
  visitor: ["object", "property"],
  aliases: ["Expression", "LVal"],
  fields: Object.assign({
    object: {
      validate: (0, _utils.assertNodeType)("Expression", "Super")
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
        const computed = (0, _utils.assertNodeType)("Expression");
        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
        validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
        return validator;
      }()
    },
    computed: {
      default: false
    }
  }, !process.env.BABEL_TYPES_8_BREAKING ? {
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }
  } : {})
});
defineType("NewExpression", {
  inherits: "CallExpression"
});
defineType("Program", {
  visitor: ["directives", "body"],
  builder: ["body", "directives", "sourceType", "interpreter"],
  fields: {
    sourceType: {
      validate: (0, _utils.assertOneOf)("script", "module"),
      default: "script"
    },
    interpreter: {
      validate: (0, _utils.assertNodeType)("InterpreterDirective"),
      default: null,
      optional: true
    },
    directives: {
      validate: (0, _utils.arrayOfType)("Directive"),
      default: []
    },
    body: (0, _utils.validateArrayOfType)("Statement")
  },
  aliases: ["Scopable", "BlockParent", "Block"]
});
defineType("ObjectExpression", {
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: {
    properties: (0, _utils.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
  }
});
defineType("ObjectMethod", {
  builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
  visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
    kind: Object.assign({
      validate: (0, _utils.assertOneOf)("method", "get", "set")
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      default: "method"
    } : {}),
    computed: {
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");
        const validator = function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
        return validator;
      }()
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }),
  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
});
defineType("ObjectProperty", {
  builder: ["key", "value", "computed", "shorthand", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])],
  fields: {
    computed: {
      default: false
    },
    key: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
        const computed = (0, _utils.assertNodeType)("Expression");
        const validator = Object.assign(function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        }, {
          oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
        });
        return validator;
      }()
    },
    value: {
      validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
    },
    shorthand: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, shorthand) {
        if (!shorthand) return;
        if (node.computed) {
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }
        if (!(0, _is.default)("Identifier", node.key)) {
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }
      }, {
        type: "boolean"
      })) : (0, _utils.assertValueType)("boolean"),
      default: false
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    }
  },
  visitor: ["key", "value", "decorators"],
  aliases: ["UserWhitespacable", "Property", "ObjectMember"],
  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
    const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
    const expression = (0, _utils.assertNodeType)("Expression");
    return function (parent, key, node) {
      const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
      validator(node, "value", node.value);
    };
  }()
});
defineType("RestElement", {
  visitor: ["argument", "typeAnnotation"],
  builder: ["argument"],
  aliases: ["LVal", "PatternLike"],
  deprecatedAlias: "RestProperty",
  fields: Object.assign({}, patternLikeCommon(), {
    argument: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
    }
  }),
  validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key) {
    const match = /(\w+)\[(\d+)\]/.exec(key);
    if (!match) throw new Error("Internal Babel error: malformed key.");
    const [, listKey, index] = match;
    if (parent[listKey].length > +index + 1) {
      throw new TypeError(`RestElement must be last element of ${listKey}`);
    }
  } : undefined
});
defineType("ReturnStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    }
  }
});
defineType("SequenceExpression", {
  visitor: ["expressions"],
  fields: {
    expressions: (0, _utils.validateArrayOfType)("Expression")
  },
  aliases: ["Expression"]
});
defineType("ParenthesizedExpression", {
  visitor: ["expression"],
  aliases: ["Expression", "ExpressionWrapper"],
  fields: {
    expression: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
defineType("SwitchCase", {
  visitor: ["test", "consequent"],
  fields: {
    test: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    consequent: (0, _utils.validateArrayOfType)("Statement")
  }
});
defineType("SwitchStatement", {
  visitor: ["discriminant", "cases"],
  aliases: ["Statement", "BlockParent", "Scopable"],
  fields: {
    discriminant: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    cases: (0, _utils.validateArrayOfType)("SwitchCase")
  }
});
defineType("ThisExpression", {
  aliases: ["Expression"]
});
defineType("ThrowStatement", {
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
defineType("TryStatement", {
  visitor: ["block", "handler", "finalizer"],
  aliases: ["Statement"],
  fields: {
    block: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function (node) {
        if (!node.handler && !node.finalizer) {
          throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }
      }, {
        oneOfNodeTypes: ["BlockStatement"]
      })) : (0, _utils.assertNodeType)("BlockStatement")
    },
    handler: {
      optional: true,
      validate: (0, _utils.assertNodeType)("CatchClause")
    },
    finalizer: {
      optional: true,
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  }
});
defineType("UnaryExpression", {
  builder: ["operator", "argument", "prefix"],
  fields: {
    prefix: {
      default: true
    },
    argument: {
      validate: (0, _u‰d$HE3äD‰L$@L‹ÎD‰d$8‰T$0H‹H‹ÏD‰D$(E3ÀÇD$    è=  …ÀtH‹MH‰L$@L‰d$8L‰d$0é‡şÿÿM…ötH‹×I‹ÎèO M‹ôH‹MˆH…Ét	è d  L‰eˆI‹O03ÀL‹E€WÀ‰EèA¹   H‹…€   H‰D$HHE¨A‹P$H‰L$@H‹ÏH‰D$8D‰d$0D‰d$(‰T$ HUØEØèö#  …ÀtH‹MH‰L$@H‹M¨H‰L$8édÿÿÿI‹G(H‹ÏL‹eD‹MhL‹E`H‹UXL‰d$8‰\$0H‰D$(‹Ep‰D$ è–Œ  3Û…ÀtH‹M¨L‰d$@H‰L$8H‰\$0é¦ıÿÿH‹u˜M…ít!I9] tH‹OI‹ÕH‹‰Ø  èö³ÿÿ…À…)ıÿÿH‹]€H…ötH‹×H‹ÎèN H…ÛtH‹Ëèõb  H‹U¨H…Òt	H‹OècüÿM…ätDH‹OI‹ÔèÆ ÿÿë6H‹E€H‹U3ÛH…ÒtH‹Oè¬ ÿÿH‹E€E‹GI‹ÖéÑûÿÿH‹M€H…Étèšb  3ÀLœ$  I‹[0I‹s8I‹{@I‹ãA_A^A]A\]ÃH‰\$H‰t$H‰|$UATAUAVAWH‹ìHì€   H‹ëÑ+ H3ÄH‰EğE3í3ÀM‰)WÀH‹ypI‹ñ‰EèA‹ØH‹BL‹òL‹ùL‰mÀE‹åEØH;€˜   …á   E3ÀH‹Ïè3‹ÿÿ…À…l  HcG<E‹Å…À~H‹OA‹ÕL;1tAÿÀHÿÂHƒÁH;Ğ|ìÿÈD;Àu\A;°   uoHEÀE3ÀLMØH‰D$ I‹ÖI‹Ïè’K …À…  H‹UÀLEÈL‹ÎI‹ÏèC³  H‹MÀI‹×‹Øè}L …Û„ä  ‹Ãéã  A;°   uH‹GAÿÀIcÈA‹İL‹4ÈëÿÃHEÀD‹ËH‰D$0I‹ÖHEØI‹ÏH‰D$(L‰l$ è{I ëƒA½   D‰mĞH‹PhH‹BH;€˜   uïE3ÀH‹Ïè7Šÿÿ…À…p  LEÌ3ÒH‹Ïè}‹ÿÿD9eÌtM‹ÁàÁøƒøuHcO<H‹GH‹TÈøëƒøu3ÒëH‹WpHEÀE3ÀLMØH‰D$ I‹Ïè’J …À…  L‹eÀL‰&L‹ÎLEÈI‹ÔI‹Ïèí³  ‹øM…ätI‹×I‹ÌèsK …ÿ…Ş   3ÿ9}Ìu*D‹ï9}Ğ…—   H‹H…ÉtI‹×èHK L‰&E…í„«   ë£H‹HƒÁƒ9uH‹IL‹AA‹FLA9@L¸M;ÆuBƒ9uA‹@H‰EÀ‹A‰EÄë'ƒ9HUÀuH‹IèixùÿëI‹ I‹ÈH‹€ø   ÿO 9]ÄDMïE…í„kÿÿÿL‹&‰}Ğé|ÿÿÿH‹LEÈH‹ÓL‹ÎI‹Ïèd±  I‹×H‹Ë‹øèŸJ 3À…ÿu9EÈuH‰3Àë‹ÇH‹MğH3Ìè_< Lœ$€   I‹[0I‹s8I‹{@I‹ãA_A^A]A\]ÃH‰\$L‰L$ D‰D$UVWATAUAVAWH‹ìHƒìpE3íL‹òL‰møH‹ùL‰mèH‹òL‰mğH…Òt1öB0€uHUHH‹Îè,xùÿ‹EHL‹MXëHBƒ8uH‹@H‹@‹@Hë‹A,A‰LMHL‰mHLEäH‹ÖH‹ÏH‹Şè…°  D‹ø…À…d  H‹uHLEøH‹ÖH‹Ïè7ø  D‹à…À…î  H‹MèH…Ét	è–^  L‰mèL‹eøHEèH‰D$@E3ÉHEàM‹ÄH‰D$8H‹ÏD‰l$0EyD‰l$(A‹×D‰l$ è4L  D‹è…À…=  H‹×I‹Ìèû  H‹EèE3í‹MPL‰mø9H$"H…Û„?ÿÿÿI;Ş„6ÿÿÿH‹×H‹ËèI é&ÿÿÿH…Ût1öC0€uHUHH‹Ëèwùÿ‹EHëHCƒ8uH‹@H‹@‹@HH‹MX‰HEğL‹ËH‰D$@E3ÀHEàA‹×H‰D$8H‹ÏD‰l$0D‰l$(D‰l$ èK  D‹à…Àt1L‹uğL‹}èH…ÛtH‹×H‹Ëè†H H…ö„   H‹×H‹ÎèrH éğ   H‹U`H‹Mğèğc  L‹uğD‹àL‹}è…Àu»H…ÛtH‹×H‹ËèAH H…ötH‹×H‹Îè1H M…ÿtI‹Ïè$]  M…ötI‹Îè]  3Àéø   L‹uğL‹}èH…ÛtH‹×H‹ËèøG H…ötH‹×H‹ÎèèG M…ätH‹×I‹Ìè˜ù  M…ÿtI‹ÏèË\  M…ötI‹Îè¾\  A‹Åé   L‹uğL‹}èH…ÛtH‹×H‹ËèG H…ötH‹×H‹ÎèG H‹MøH…ÉtH‹×è=ù  M…ÿtI‹Ïèp\  M…ötI‹Îèc\  A‹ÄëFH‹uğL‹uèH…ÛtH‹×H‹ËèFG H‹MHH…ÉtH‹×è5G M…ötI‹Îè(\  H…ötH‹Îè\  A‹ÇH‹œ$°   HƒÄpA_A^A]A\_^]ÃH‹ÄH‰XL‰H L‰@H‰PUVWATAUAVAWHhÁHì°   H‹ÂH‹ù3Ò‰U»D‹âH‰UÇH‰U÷H‰UÏD‹úH‰UçÇEïÿÿÿ?‹Ú‰UÛ‰U·‰U¿‰U×‰UßDRE‹êH‹   ‰H‹¯   H…ÉtH‰L‹µ§   I‰9Ug„â   M…É…Ù   ‰•§   M…À‹Êui‹H‹@HUÏH‰T$@HUÿH‰T$8‰L$0‰D$(‹…‡   ‰D$ E3ÉA‹ÒH‹ÏèúH  ‹ğ…Àt/I‹H…ÉH‹]ÏtH‹×èF M‰>H…ÛtH‹ËèôZ  ‹Æé­  ‹Âë™D9}t1HEóH‰D$(H…§   H‰D$ LM·LEÛ3ÒH‹MÏèCç  ‹ğ…Àu‹]ÛL‹}ÏA‹G$+…§   +ÃL‰}çL!eÏH‹—   D‰)M!&‰EïHE÷H‰D$ D‹MwD‹EoH‹UWH‹Ïèİ¯  ‹ğ…ÀtCH‹]ÏM…ÿtI‹ÏèVZ  H‹M÷H…ÉtI;tH‹×è@E I‹H…É„3ÿÿÿH‹×è,E M!&é#ÿÿÿH‹]÷H‹uWH…öt?H…Ût:öC0€uH•§   H‹Ëèsùÿ‹…§   ëHCƒ8uH‹@H‹@‹@H9F(W  H‹ó3ÛLMÇLE»H‹ÖH‹Ïèx«  ‰…§   E3À…À„€   H‹]ÇL‹ëL‹eÏM…ÿtI‹Ïè—Y  M‹>M…ÿt(H‹×I‹Ïè„D E3ÀM‰A‹ØM;ïIEİA‹ÀI;÷HEÆH‹ğH…ÛtH‹×H‹ËèWD M…ätI‹ÌèJY  H…ötH‹×H‹Îè:D ‹…§   éï  L‹eÇD9E»t"H‹EWH…ÀtI‹ÔH‹Èèaö  E3À…ÀEEèI‹ÜëE‹èE…í„\  ƒ}×N  H‹UWH…ÒuH‹MO‹A‹IëA‹ÀA‹ÈLEÛL‰D$XL…§   L‰D$PLEïL‰D$HLEçL‰D$@D‹ED‰D$8‰D$0‰L$(‹…‡   ‰D$ D‹MwM‹ÄH‹ÏèÙ  ‰E·3Ò…À…  D‹½§   E…ÿt(I‹H…ÉtH;ÎtH;Ët
H‹×èNC 3ÒM‰&H‹…—   ‰9UÛtÿE×ëÿEßI;ÜuD‰}¿ë9U¿tE…ÿÇE¿   t‰U¿H…ötH;ótI96tH‹×H‹ÎèúB 3ÒI‹ôH‰UÇLMÇLE»I‹ÔH‹Ïè–©  ‰E·E3À…À…ü   L‹eÇD9E»tH‹EWH…ÀtI‹ÔH‹Èèõ  E3À…ÀtE‹èE…í…¨şÿÿL‹}çH…ötH;ótI;6tH‹×H‹ÎèB M…ätL;ãtM;&tH‹×I‹ÌègB LMÇLE»H‹ÓH‹Ïè¼ª  ‰E·3ÒH‹uÇ…À„x  L‹îL‹eÏM…ÿtI‹Ïè/W  M‹>M…ÿt%H‹×I‹ÏèB 3ÒI‰‹òM;ïIEõ‹ÂI;ßHEÃH‹ØH…ötH‹×H‹ÎèòA M…ätI‹ÌèåV  H…Û„	  H‹Ëéù   L‹}ÇM‹çL‹mÏH‹MçH…Étè»V  H…ÛtI;ÜtH;ŞtI;tH‹×H‹ËèœA I‹H…Ût(H‹×H‹Ëè‰A E3ÀM‰E‹øL;ãMEüA‹ÀH;óHEÆH‹ğM…ÿtwI‹ÏëjM‹üL‹mÏH‹MçH…ÉtèMV  H…ÛtI;ßtH;ŞtI;tH‹×H‹Ëè.A I‹H…Ût&H‹×H‹ËèA 3ÒI‰D‹âL;ûMEç‹ÂH;óHEÆH‹ğM…ätI‹ÌH‹×èğ@ M…ítI‹ÍèãU  H…ötH‹ÎH‹×èÓ@ ‹E·é‹  L‹m_9U»„©  M…ítH‹ÖI‹ÍèÎA 3Ò…À…  A¿   L‹eW‹Eßƒøu  E×ƒøi  M…ätAöF0€uHU·H‹Îè‹nùÿ‹E·3ÒëHFƒ8uH‹@H‹@‹@H‰E·A9D$(³   ‹Â‹Êë
H‹MO‹A‹IHUÛH‰T$XH•§   H‰T$PHUïH‰T$HHUçH‰T$@‹U‰T$8‰D$0‰L$(‹…‡   ‰D$ D‹MwL‹ÆI‹ÔH‹Ïè8  ‰Eó3Ò…À…ì   9•§   t,I‹H…ÉtH;Ët
H‹×è¶? 3ÒI‰6ÇE¿   H‹…—   ‰ë‰U¿9UÛtÿE×ëÿEßH…ÛtI;tH‹×H‹Ëèz? 3ÒH‹ŞH‰UÇLMÇLE»H‹ÖH‹ÏèÆ§  ‰Eó3ÒH‹uÇ…Àuj9U»t'M…ít%I‹ÕH‹Îè\@ 3Ò…ÀuI‹ÕH‹Îè‹? 3Ò…ÀtD‹úE…ÿ…şÿÿL‹}çM…ÿ„œ   9U¿tM…íu	9Ug„‰   H‹…   Ç    é¢   H‹MçH…ÉL‹eÏL‹îtèÒS  M‹>M…ÿt%H‹×I‹Ïè¿> 3Ò‹òM;ïIEõ‹ÂI;ßHEÃI‰H‹ØH…ötH‹×H‹Îè•> M…ätI‹ÌèˆS  H…ÛtH‹×H‹Ëèx> ‹Eóé0  L‹¥   A‰$M…ÿ„Â   I‹ÏèTS  3ÒD‹úA9$„«   H‹…¯   H…À„›   H‹OH‹ĞH‹‰Ø  èú£ÿÿD‹è3Ò…ÀtH‰µ   L‹eÏM…ÿtI‹ÏèS  M‹>M…ÿt-H‹×I‹Ïèî= 3ÒI‰‹òL9½   HEµ   ‹ÂI;ßHEÃH‹ØH…ötH‹×H‹Îè¼= M…ätI‹Ìè¯R  H…ÛtH‹×H‹ËèŸ= A‹ÅëZH‹…Ÿ   L‰8H‹·   ‹Eï‰I;6HDòL‹úI;LEûH‹]ÏH…ötH‹×H‹Îè_= H…ÛtH‹ËèRR  M…ÿtH‹×I‹ÏèB= 3ÀH‹œ$ğ   HÄ°   A_A^A]A\_^]ÃH‰\$WHƒì0H‹AHH‹ÚH…ÀtV¿   D‹ÇH‹ĞH‹ËèÕ  …ÀuAHK9~.H‹AH‹PH‹B÷@    tD‹Ï‰|$ D‹Ç‹×è=d ë3À…ÀuH‹CXH…Àu¯3ÀH‹\$@HƒÄ0_ÃL‹ÜI‰[I‰sI‰{UATAUAVAWH‹ìHƒìpH‹…€   3ÛL‹­ˆ   E‹ñ‹uXM‹ÈL‹Â‰SHEğA‰] I‰C¨HEàI‰C ‹E`‰D$0‹EP‰t$(‰D$ è?  …À…e  9]à„\  ‹Ã‰ˆ   9]htDH‹MğHEäH‰D$(LMìHEè3ÒL…ˆ   H‰D$ èİ  ‹ø…ÀtH‹MğèèP  ‹Çé  ‹…ˆ   H‹MğL‹exL‹}p‹y$+ø+şE94$~A;<$Œ²   E94$}A;<$~A;ş   A;<$…º   ‹A L‹AƒàM…Àt,…Àt‹qHë.I‹ H•ˆ   I‹ÈH‹@(ÿª? H‹Mğ‹µˆ   ë…ÀuÔH‹A‹p,I‹‹P L‹@ƒâM…Àt,…Òt‹@Hë.I‹ H•ˆ   I‹ÈH‹@(ÿa? ‹…ˆ   H‹Mğë…ÒuÔH‹@‹@,;ğ~'A‰<$I9tI‹èõO  H‹MğH‹…€   I‰Ç    ëèÚO  A;şÃA‰] 3ÀL\$pI‹[0I‹s8I‹{@I‹ãA_A^A]A\]ÃH‹ÄH‰XH‰pH‰xL‰H UATAUAVAWH‹ìHì€   H‹E`LMğ3ÛM‹èLEĞ‰]ĞH‹ù‰]Ô‰D‹ûH‹EpH‰]è‰]ÜH‰]ğ‰è–  …À…÷  H‹]ğL‹óL‹eXH‹óD9}Ğ„  I‹E(L‹ËA‹UE3ÀL‰d$@ÁêH‹ƒâHEÔH‰D$8‹A‰D$0‹AH‹Ï‰D$(‰T$ 3ÒèĞ<  ‹ğ…ÀtH…ÛtH‹×H‹ËèŞ9 ‹Æé  H‹óé   D9}Ô…©   LMğH‹ÓLEĞH‹ÏèÎ“  ‹Ø…À…  H‹×I‹Îè9 H‹]ğL‹óH‹óD9}ĞtgI‹E(L‹ËA‹UE3ÀL‰d$@ÁêH‹ƒâHEÔH‰D$8‹A‰D$0‹AH‹Ï‰D$(‰T$ 3Òè(<  ‰Eà…À…™   H‹MPC0‹C@‰AD9}Ğ…WÿÿÿD9}Ô„°   A‹EHMèL‹EHA¹   A‹UH‰L$@HMÜH‰L$8I‹$Áèƒà‰D$0ÇD$(   ÇD$    èÍZ  D‹ğ…ÀtYH…ötH‹×H‹Ëè¾8 H‹MèH…Étè4_  A‹ÆéR  H…Û„I  H‹×H‹Ëè”8 ‹Eàé6  M…ötH‹×I‹Îè|8 ‹Ãé  D‹}Üé×   I‹E(E3ÉA‹UE3ÀL‰d$@ÁêH‹ƒâHEØH‰D$8‹A‰D$0‹AH‹Ï‰D$(‰T$ 3Òè;  D‹ğ…ÀtH…ö„kÿÿÿH‹×H‹Ëè8 é[ÿÿÿD9}ØtfA‹EHMèL‹EHº   H‰L$@D‹ÊÁèHMØH‰L$8#ÂI‹$‰D$0‰T$(‰T$ A‹Uè½Y  D‹ğ…À…ìşÿÿD9}ØtAƒ} |HH‹EhD‹ù‰ë
H‹EpÇ    H‹E`D‰8E…ÿuI‹$H…Ét
è{L  Iƒ$$ H…ÛtH‹×H‹Ëèf7 H‹MèH…ÉtèÜ]  3ÀLœ$€   I‹[0I‹s8I‹{@I‹ãA_A^A]A\]ÃL‹ÜI‰[I‰sM‰CUWATAUAVH‹ìHƒì`H‹EXLEğL‹e`H‹ùL‹uh3ÉM‹é‰Mğ‰LM`H‹EP‰MôH‰MøA‰$H‰HEøA‰H‹ÏI‰C˜èûÿE3À…À…R  H‹]øH‹óD9Eğ„  H‹E@D9E`tƒ8Œş   AÇ$   ƒ8|wD9Ctƒ{A‹ĞuH‹K‹C9°   ”Â…ÒtTH‹Kèü2  E3ÀL‹ğH…Àt@H‹H‹ApI‹Îÿ: E3À…Àu!I‹H‹AI‹Îÿv: E3À…ÀtAö†¸   tAÇ$   H‹E@L‹ËL‹uPL‰t$@H‹@(H‹H‹E@‹PHEôH‰D$8‹AÁêƒâ‰D$0E9$‹AH‹ÏMEÈ‰D$(‰T$ E3À3Òè¥8  E3À‰EP…Àt/H…Û„C  H‹×H‹Ëè«5 ‹EPé0  H‹EXAÇ   D‰ é  E9$„­   WÀ3ÀAE éª   ‹Eô…À…Ê   LMøH‹ÓLEğH‹ÏèÕ  ‹Ø…À…’   H‹×H‹ÎèD5 H‹]øE3ÀH‹óD9Eğ„‹   H‹U@L‹ËL‰t$@H‹B(‹RÁêƒâH‹HEôE9$H‰D$8MEÈ‹A‰D$0‹AH‹Ï‰D$(‰T$ 3ÒèÃ7  E3À‰EP…À…ÿÿÿC0AE ‹C@A‰ED9Eğ…HÿÿÿëH…ötH‹×H‹Îè­4 ‹Ãë6L‹uP‹EôH‹MX‰…ÀuI‹H…Étè‹I  E3ÀM‰H…ÛtH‹×H‹Ëèu4 3ÀL\$`I‹[0I‹s8I‹ãA^A]A\_]ÃL‹ÜI‰[I‰sI‰{ UATAUAVAWH‹ìHƒìpH‹EXE3ÿH‹]hM‹èL‹áL‰}èL‰8A÷@   D‰;tXA‹xHMhI‰K¨I‹ÌI‰[ H‹]`I‰[˜I‰CH‹EPI‰CˆAÇ@ÿÿÿ?è0ùÿÿ…À…½  D9;t	pD9}htA‹÷‰3A‰}éŸ  H‹}`HEèH‰D$(L‹ÏHE@E3ÀH‰D$ èÃ•  …À…x  L‹uè¾   H‹MPAF0A‹F@‰AAƒ} ŒÎ  A‹N…ÉuI‹D$PI9F„  …Ét A‹×;ÎuI‹NA‹F9°   ”Â…Ò„œ  I‹~H‹Ïè¹/  L‹øH…À„„  H‹OH‹AI‹H‰Eè‰u@H‹ApI‹Ïÿ:7 …À„¿   H‹EèH‹€    H‰EøH…À„–   I‹OHUàE‹GHH‹H‹€Ğ   ÿş6 H‹HUğ‹]àH‹ÏH‹€ø   ÿä6 H‹OHUäD‹EğDEôL‹I‹‚Ğ   ÿÄ6 H‹OHE@D‹EäH‰D$ H‹EèH‹‘˜   H‹HH‹EøH‹’À   D‹Ëÿ6 …À…-  H‹]hƒ}@ „À   ‰3é  I‹I‹ÏH‹@ÿc6 …À„†  Aö‡¸   „x  H‹EèH‹€    H‰EøH…ÀtµI‹OHUäE‹GHH‹H‹€Ğ   ÿ6 H‹HUğ‹]äH‹ÏH‹€ø   ÿ6 H‹OHUàD‹EğDEôL‹I‹‚Ğ   ÿã5 H‹OHE@D‹EàH‰D$ H‹EèH‹‘˜   H‹HH‹EøéÿÿÿI‹OHUhE‹GHH‹H‹€Ğ   ÿ5 H‹HUğH‹ÏH‹€ø   ÿ‡5 H‹OHUäD‹EğDEôL‹	I‹Ğ   ÿg5 ‹Eh+Eä…À„   H‹H‹ÏH‹@ ÿI5 …ÀtpI‹OHUhE‹GHH‹H‹€Ğ   ÿ)5 H‹HUğH‹ÏH‹€ø   ÿ5 H‹OHUäD‹EğDEôL‹	I‹Ğ   ÿò4 ‹Eh	·   +Eä‰‡”   ë	D9}@tD‰?H‹}`E3ÿD9?taI‹E(M‹ÎE‹U‹ÖAÁêI‹ÌD#ÖL‹ H‹EXD9;H‰D$@A‹@MEÏH‰|$8‰D$0A‹@E3À‰D$(D‰T$ è3  ‹Ø…ÀtI‹ÔI‹Îè,0 ‹ÃëI‹ÔI‹Îè0 3ÀL\$pI‹[0I‹s8I‹{HI‹ãA_A^A]A\]ÃL‹ÜI‰[I‰kVWAVHƒìpH‹B0A‹ù‹¬$°   MKE‹ğI‰C˜H‹ÚD‹Å‹×H‹ñèÈ¡  …À…   L‹„$Ø   ‹„$˜   L‰D$hƒàÁàAƒ` ßA	@ L‹ÃH‹C(D‹SE‹ÊAÁéAƒáAÁêH‹AƒâH‹PH‹„$Ğ   H‰D$`‹A`H‹ÎH‹‰D$X‹„$È   ‰D$P‹„$À   ‰D$H‹„$¸   ‰D$@‰l$8‰|$0D‰L$(E‹ÎD‰T$ è   L\$pI‹[ I‹k0I‹ãA^_^ÃH‹ÄH‰XH‰PUVWATAUAVAWHƒìPƒ`  E‹áH‹´$ğ   I‹èL‹yL‹ñH…ötHƒ& H‹¼$ø   3À‹œ$è   H‰Aƒ8tAƒ8t¸   ë8H‹H”$ğ   D‹A,H‹€Ğ   ÿÅ2 D‹ÃH”$ø   I‹Îèb3ûÿ‹ +„$ğ   D‹Œ$°   Lo‰L‹ÅH‹”$˜   3ÀD‰gI‹ÎH‰GLg‰G‹„$À   ‰G,‹„$È   ‰G0‹„$Ø   ‰G4‹„$à   ‰G8H„$À   H‰D$HH„$¨   H‰D$@‹„$¸   L‰l$8L‰d$0‰\$(‰D$ èÌ  …Àui‹„$À   3G ƒà3G ƒ¼$¨    tƒÈëƒà÷‰G H…öt,Aö‡,  t"A‹E ƒøw¹`ñ  £ÁsH‹ÖI‹Îè2   …ÀuA‹$‰G‹„$Ğ   ‰G(3ÀH‹œ$   HƒÄPA_A^A]A\_^]ÃH‹ÄH‰XH‰h VWAVHì€   H‹YLHƒ` L@Hƒ` L‹ò‹‘¬   H‹éH‹‰    èasûÿ…À…à   ‹´$    …öÏ   H”$    H‹Ëèÿÿ‹ø…ÀtH‹”$°   H‹Ëè||üÿ‹Çé¤   ƒd$p A¸   ƒd$h A¹ÿÿ  ‹E,H‹ÍH‹¼$°   D‰D$`Hƒd$X ƒd$P ƒd$H ‰D$@H‰|$8‰t$0H‹´$    Hƒd$( H‹ÖHƒd$  èŸƒÿÿ‹èH‹Ë…ÀtH‹×è|üÿH‹ÖH‹ËèCÿÿ‹Åë"I‹Öè{|üÿ‹èH‹×H‹Ë…ÀuØI‹H‰pèÓ{üÿ3ÀLœ$€   I‹[(I‹k8I‹ãA^_^ÃH‰\$D‰L$ H‰T$UVWATAUAVAWHƒì0H‹é3ÛL‹¼$°   A‰I‹Èè—ÿÿL‹´$¨   A‰A‹ ƒøw¹@
  £Á‹„$˜   r‹E,H‹´$    ‰E‹&¿   GD;àuj‰œ$°   L‹mA÷…,     tRD‹H”$¨   H‹Íè^0ûÿLŒ$°   D‹ H‹T$xI‹MI‹…˜   ÿ/ …ÀuyD‹Œ$ˆ   9œ$°   t	AÇ	   >A‹AúA½   A;ÅwLE…Ét#A‰?ƒét+Ït+ÏtN;Ïu¿   H‹„$¸   ‰8H‹Íèra  …Àu9œ$   tÿA‰E;åADİA‰3ÀH‹\$pHƒÄ0A_A^A]A\_^]Ã‹ûë·ÌH‹ÄH‰XD‰H H‰PUVWATAUAVAWHƒì03ÿE‹á‰xM‹ğH‹AL‹ù÷€,     t1I‹HH…Éu
I‹@H‹HPëH‹I0H‹H‹€à   ÿ‘. A½   …ÀuD‹ïH‹´$¨   H…ötH‰>A‹_,H…ötI‹NH‹H‹@ÿZ. …ÀtI‹Gö€,  t[H”$¨   I‹Îè‰E  …À…Í  H‹¬$¨   H…ít6I‹OH‹ÖèzüÿD‹à…ÀtI‹OH‹Õè¹|ÿÿA‹Äé›  H‹D‹¤$ˆ   H‰hL‹Œ$°   LD$pI‹×I‹Îèî—  …À…l  H‹´$¸   A‹G,‰FI‹NH…Ét+AöF tA‹FHë,H‹H”$¨   H‹@(ÿ”- ‹„$¨   ëAöF uÕI‹F‹@,‰FE…ít‹F‰F‹n @öÅ@tBD‹F$H”$¨   I‹Ïè.ûÿD‹FHT$ I‹ÏH‹Øèî-ûÿ‹+‰E…ät
…ÉÇ   D‹åë8û  ğ|û  tI‹‡˜   ˜¸  D‹FH”$¨   I‹ÏD‹åè -ûÿ+‰H‹L$x‹¨t$öØÿ÷ßÿÇëƒà`<`u¿   ëA‹ì‰~ƒå÷‹„$ˆ   ‰FòAòF‹A‰F‹„$   ‰F(‰n A‹F(‰F,A‹F,‰F0‹„$˜   ‰F4‹„$    ‰F8‹D$pÁà3Åƒà 3Å‰F 3ÀH‹œ$€   HƒÄ0A_A^A]A\_^]ÃH‰\$H‰t$ UWATAVAWH‹ìHƒìPAƒ8 IxM‹ñM‹øL‹âH‹Ù¾   t3ÒA90uH‹‹G9°   ”Â…ÒtH‹HU0H‹H‹€ğ   ÿã+ ‹E0ÿÀëH‹‹@LÆH‹KpE3É‰D$8E3Àƒd$0 3ÒL‰|$(H‰L$ H‹Ëè1jÿÿA¿   …À…  H‹CH‹?D„¸,  t-‹ƒ€   „Àx#ºàsH‹ƒ    ö@@DtH‹Ëè}  …À…Å  öƒ€    t]HE0H‹×LMôH‰D$ LEøH‹Ëèµ˜
 …À…˜  H‹EøH‰CPH…ÀuH!CHH‰C`H…ÀuH!CX‹Kx‹U0÷Ú‰Cxèôµøÿ…À…_  3À…À…U  I‹ö t6D‹CxLM0H‹SPI‹NèÕz …À…0  ‹Kx‹U0‰Cxè¬µøÿ…À…  I‹FLM0H‹KPD‹@\HEğH‰D$0HE@H‰D$(HEôAÁèD#ÆH‰D$ èáÂ  …À…Ø   A‹$…Àx=  tH‹‹˜   +¸  ‹K,;ÈL‹EX‹UPNÈD‹M@ÁâAƒ  A3P A‰@ƒâ A3P A‰HA‹L$A‰HA‹D$A‰@‹Cx+E0A+ÁA‰@(òAD$òA@A‹D$ A‰@A‰P I‹F÷@\   t(Aúƒøw ƒÊƒét+Ît+ÎtJ;ÎuA‹÷ƒâøÖA‰P I‹‹HA‰H,I‹‹H‹EğA‰@83ÀA‰H0E‰H4L\$PI‹[8I‹sHI‹ãA_A^A\_]Ã3öë¹ÌH‰\$H‰t$WHƒì H‹ñ3ÛH‹JH‹úH…Étè:  H‹W H…ÒtH‹Ø  ènˆÿÿ…ÀEØH‹W(H…ÒtH‹Ø  èì‡ÿÿ…ÀEØH‹t$8‹ÃH‹\$0HƒÄ _ÃH‰\$H‰l$ VWAUAVAWHƒì 3öÇ   €L‹úL‹ñE…Àt,H‹IH‹H‹€à   ÿÇ( …ÀtI‹Fn‹HHÍA‰é^  I~ƒ?uH‹G‹ë‹½   ;Í…  ƒ?A‹^4uL‹oëL‹ïM‹mA‹•°   uH‹OëH‹Ï‹Â+A;Ø}ƒ?uH‹‹GÿÀAEHÃéñ  ƒ?uH‹GëH‹ÇI‹ME3À‹@+ÂI‹ÕØH‹Ipèbÿÿ…À…‘  ƒ?uH‹M‹U‹OÍM‹ZpA;K<}(M‹CIc{<HcÑI‹ĞD‹ˆ°   A;Ù|OA+ÙÍHÕH;×|ãI‹ËèÙrúÿH9p „’   LD$`èåcÿÿ…À…)  M‹MI‹Qp‹
ÁáÁùƒùuH‹BL‹ ëHcÁI‹À‹IHÿÁËéÅşÿÿƒùt(L‹BpM…Àtƒùu	H‹BH‹0ë	ƒùtH‹rp‹NHé–şÿÿI‹I‹ÉH‹€¸   HT$Xÿ7' ‹HévşÿÿM;’˜   uAö…¸   „’   I‹I‹ÊëÅI‹~E3ÀH‹×H‹GH‹XpH‹Ëèè`ÿÿ…ÀulH‹ËèøqúÿH9p t^LD$`ècÿÿ…ÀuP‹ÁáÁùƒùu	H‹CH‹ë	ƒùt)H‹SpH…Òt ƒùu	H‹Cé=ÿÿÿƒù„BÿÿÿH‹spé9ÿÿÿH‹OH‹é;ÿÿÿ3Àë1AöF0€uHT$`I‹ÎèLPùÿ‹D$`ëƒ?uH‹H‹G‹@HÿÀA‰‹ÅH‹\$PH‹l$hHƒÄ A_A^A]_^ÃH‰\$H‰l$H‰t$WHƒì0‹éI‹ùH‹L$pI‹ğH‹ÚH…ÉtèŠÓ  LD$hH‹ËHT$`è8   H‹„$€   L‹ÇL‹L$xH‹ÖH‹ËH‰D$ èX   H‹\$@‹ÅH‹l$HH‹t$PHƒÄ0_ÃH‰\$WHƒì H‹úI‹ØH‹ÑH‹H…Ét	è`! Hƒ' H‹H…Ét	èO6  Hƒ# H‹\$0HƒÄ _ÃH‰\$H‰t$WHƒì I‹ñI‹øH‹ÂH‹ÙH…ÒtH‹ÑH‹Èè! H…ÿtH‹Ïè6  H…ötH‹KH‹ÖèwqüÿH‹T$PH…Òt	H‹KèØsÿÿH‹\$0H‹t$8HƒÄ _ÃHƒìHH…ÒuH‹D$p3ÉH‰‰HH‹D$xH‰‰H3ÀHƒÄHÃö€   €u,H‹Aö€,  tH‹D$xH‰D$(H‹D$pH‰D$ èU   …ÀtÆëÆE3ÒH‰T$0H;‰˜   A”ÂM…ÀtI‹@ H‰D$8ëHƒd$8 H‹D$xHT$0L‹L$pHh  E‹ÂH‰D$ è‡  ë¬ÌH‰\$ UVWATAUAVAWHl$àHì   H‹¥¤+ H3ÄH‰EH‹…ˆ   E3öL!u€I‹ØL‹½€   H‹úH‰D$`H‹ñH‹AH‰D$hD‰L$PL‰}ˆL‰t$XH‰T$pM…ÀtI‹@ H‰D$xëL!t$xH;yHu‹¹¨   ëAH‹H‹ÏH‹@ ÿÌ# …Àu"H‹H‹ÏH‹@ ÿ¸# …Àu	H‹   fields: Object.assign({}, importAttributes, {
    module: {
      optional: true,
      validate: (0, _utils.assertValueType)("boolean")
    },
    phase: {
      default: null,
      validate: (0, _utils.assertOneOf)("source", "defer")
    },
    specifiers: (0, _utils.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
    source: {
      validate: (0, _utils.assertNodeType)("StringLiteral")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
      optional: true
    }
  })
});
defineType("ImportDefaultSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
defineType("ImportNamespaceSpecifier", {
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
defineType("ImportSpecifier", {
  visitor: ["imported", "local"],
  builder: ["local", "imported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    local: {
      validate: (0, _utils.assertNodeType)("Identifier")
    },
    imported: {
      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
    },
    importKind: {
      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
      optional: true
    }
  }
});
defineType("ImportExpression", {
  visitor: ["source", "options"],
  aliases: ["Expression"],
  fields: {
    phase: {
      default: null,
      validate: (0, _utils.assertOneOf)("source", "defer")
    },
    source: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    options: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    }
  }
});
defineType("MetaProperty", {
  visitor: ["meta", "property"],
  aliases: ["Expression"],
  fields: {
    meta: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function (node, key, val) {
        let property;
        switch (val.name) {
          case "function":
            property = "sent";
            break;
          case "new":
            property = "target";
            break;
          case "import":
            property = "meta";
            break;
        }
        if (!(0, _is.default)("Identifier", node.property, {
          name: property
        })) {
          throw new TypeError("Unrecognised MetaProperty");
        }
      }, {
        oneOfNodeTypes: ["Identifier"]
      })) : (0, _utils.assertNodeType)("Identifier")
    },
    property: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
const classMethodOrPropertyCommon = () => ({
  abstract: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  accessibility: {
    validate: (0, _utils.assertOneOf)("public", "private", "protected"),
    optional: true
  },
  static: {
    default: false
  },
  override: {
    default: false
  },
  computed: {
    default: false
  },
  optional: {
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
  },
  key: {
    validate: (0, _utils.chain)(function () {
      const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
      const computed = (0, _utils.assertNodeType)("Expression");
      return function (node, key, val) {
        const validator = node.computed ? computed : normal;
        validator(node, key, val);
      };
    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
  }
});
exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
const classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
  params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
  kind: {
    validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
    default: "method"
  },
  access: {
    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
    optional: true
  },
  decorators: {
    validate: (0, _utils.arrayOfType)("Decorator"),
    optional: true
  }
});
exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
defineType("ClassMethod", {
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
  builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
  visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
defineType("ObjectPattern", {
  visitor: ["properties", "typeAnnotation", "decorators"],
  builder: ["properties"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign({}, patternLikeCommon(), {
    properties: (0, _utils.validateArrayOfType)("RestElement", "ObjectProperty")
  })
});
defineType("SpreadElement", {
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  deprecatedAlias: "SpreadProperty",
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
defineType("Super", {
  aliases: ["Expression"]
});
defineType("TaggedTemplateExpression", {
  visitor: ["tag", "typeParameters", "quasi"],
  builder: ["tag", "quasi"],
  aliases: ["Expression"],
  fields: {
    tag: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    quasi: {
      validate: (0, _utils.assertNodeType)("TemplateLiteral")
    },
    ["typeParameters"]: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }
  }
});
defineType("TemplateElement", {
  builder: ["value", "tail"],
  fields: {
    value: {
      validate: (0, _utils.chain)((0, _utils.assertShape)({
        raw: {
          validate: (0, _utils.assertValueType)("string")
        },
        cooked: {
          validate: (0, _utils.assertValueType)("string"),
          optional: true
        }
      }), function templateElementCookedValidator(node) {
        const raw = node.value.raw;
        let unterminatedCalled = false;
        const error = () => {
          throw new Error("Internal @babel/types error.");
        };
        const {
          str,
          firstInvalidLoc
        } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
          unterminated() {
            unterminatedCalled = true;
          },
          strictNumericEscape: error,
          invalidEscapeSequence: error,
          numericSeparatorInEscapeSequence: error,
          unexpectedNumericSeparator: error,
          invalidDigit: error,
          invalidCodePoint: error
        });
        if (!unterminatedCalled) throw new Error("Invalid raw");
        node.value.cooked = firstInvalidLoc ? null : str;
      })
    },
    tail: {
      default: false
    }
  }
});
defineType("TemplateLiteral", {
  visitor: ["quasis", "expressions"],
  aliases: ["Expression", "Literal"],
  fields: {
    quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
    expressions: {
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function (node, key, val) {
        if (node.quasis.length !== val.length + 1) {
          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);
        }
      })
    }
  }
});
defineType("YieldExpression", {
  builder: ["argument", "delegate"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    delegate: {
      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {
        if (val && !node.argument) {
          throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }
      }, {
        type: "boolean"
      })) : (0, _utils.assertValueType)("boolean"),
      default: false
    },
    argument: {
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
defineType("AwaitExpression", {
  builder: ["argument"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: {
    argument: {
      validate: (0, _utils.assertNodeType)("Expression")
    }
  }
});
defineType("Import", {
  aliases: ["Expression"]
});
defineType("BigIntLiteral", {
  builder: ["value"],
  fields: {
    value: {
      validate: (0, _utils.assertValueType)("string")
    }
  },
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
defineType("ExportNamespaceSpecifier", {
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: {
    exported: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
defineType("OptionalMemberExpression", {
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression"],
  fields: {
    object: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    property: {
      validate: function () {
        const normal = (0, _utils.assertNodeType)("Identifier");
        const computed = (0, _utils.assertNodeType)("Expression");
        const validator = Object.assign(function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        }, {
          oneOfNodeTypes: ["Expression", "Identifier"]
        });
        return validator;
      }()
    },
    computed: {
      default: false
    },
    optional: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
    }
  }
});
defineType("OptionalCallExpression", {
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments", "optional"],
  aliases: ["Expression"],
  fields: Object.assign({
    callee: {
      validate: (0, _utils.assertNodeType)("Expression")
    },
    arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
    optional: {
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
    },
    typeArguments: {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
    }
  }, {
    typeParameters: {
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
    }
  })
});
defineType("ClassProperty", {
  visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
  aliases: ["Property"],
  fields: Object.assign({}, classMethodOrPropertyCommon(), {
    value: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    variance: {
      validate: (0, _utils.assertNodeType)("Variance"),
      optional: true
    }
  })
});
defineType("ClassAccessorProperty", {
  visitor: ["decorators", "key", "typeAnnotation", "value"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
  aliases: ["Property", "Accessor"],
  fields: Object.assign({}, classMethodOrPropertyCommon(), {
    key: {
      validate: (0, _utils.chain)(function () {
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
        const computed = (0, _utils.assertNodeType)("Expression");
        return function (node, key, val) {
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
    },
    value: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    declare: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    variance: {
      validate: (0, _utils.assertNodeType)("Variance"),
      optional: true
    }
  })
});
defineType("ClassPrivateProperty", {
  visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
  builder: ["key", "value", "decorators", "static"],
  aliases: ["Property", "Private"],
  fields: {
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    value: {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    },
    typeAnnotation: {
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    },
    static: {
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
    },
    readonly: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    optional: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    definite: {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    },
    variance: {
      validate: (0, _utils.assertNodeType)("Variance"),
      optional: true
    }
  }
});
defineType("ClassPrivateMethod", {
  builder: ["kind", "key", "params", "body", "static"],
  visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
    kind: {
      validate: (0, _utils.assertOneOf)("get", "set", "method"),
      default: "method"
    },
    key: {
      validate: (0, _utils.assertNodeType)("PrivateName")
    },
    body: {
      validate: (0, _utils.assertNodeType)("BlockStatement")
    }
  })
});
defineType("PrivateName", {
  visitor: ["id"],
  aliases: ["Private"],
  fields: {
    id: {
      validate: (0, _utils.assertNodeType)("Identifier")
    }
  }
});
defineType("StaticBlock", {
  visitor: ["body"],
  fields: {
    body: (0, _utils.validateArrayOfType)("Statement")
  },
  aliases: ["Scopable", "BlockParent", "FunctionParent"]
});

//# sourceMappingURL=core.js.map
