{"version":3,"file":"sourcemap-codec.mjs","sources":["../src/vlq.ts","../src/strings.ts","../src/scopes.ts","../src/sourcemap-codec.ts"],"sourcesContent":["import type { StringReader, StringWriter } from './strings';\n\nexport const comma = ','.charCodeAt(0);\nexport const semicolon = ';'.charCodeAt(0);\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n\nexport function decodeInteger(reader: StringReader, relative: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = reader.next();\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  return relative + value;\n}\n\nexport function encodeInteger(builder: StringWriter, num: number, relative: number): number {\n  let delta = num - relative;\n\n  delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n  do {\n    let clamped = delta & 0b011111;\n    delta >>>= 5;\n    if (delta > 0) clamped |= 0b100000;\n    builder.write(intToChar[clamped]);\n  } while (delta > 0);\n\n  return num;\n}\n\nexport function hasMoreVlq(reader: StringReader, max: number) {\n  if (reader.pos >= max) return false;\n  return reader.peek() !== comma;\n}\n","const bufLength = 1024 * 16;\n\n// Provide a fallback for older environments.\nconst td =\n  typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n    ? {\n        decode(buf: Uint8Array): string {\n          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n          return out.toString();\n        },\n      }\n    : {\n        decode(buf: Uint8Array): string {\n          let out = '';\n          for (let i = 0; i < buf.length; i++) {\n            out += String.fromCharCode(buf[i]);\n          }\n          return out;\n        },\n      };\n\nexport class StringWriter {\n  pos = 0;\n  private out = '';\n  private buffer = new Uint8Array(bufLength);\n\n  write(v: number): void {\n    const { buffer } = this;\n    buffer[this.pos++] = v;\n    if (this.pos === bufLength) {\n      this.out += td.decode(buffer);\n      this.pos = 0;\n    }\n  }\n\n  flush(): string {\n    const { buffer, out, pos } = this;\n    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n  }\n}\n\nexport class StringReader {\n  pos = 0;\n  private declare buffer: string;\n\n  constructor(buffer: string) {\n    this.buffer = buffer;\n  }\n\n  next(): number {\n    return this.buffer.charCodeAt(this.pos++);\n  }\n\n  peek(): number {\n    return this.buffer.charCodeAt(this.pos);\n  }\n\n  indexOf(char: string): number {\n    const { buffer, pos } = this;\n    const idx = buffer.indexOf(char, pos);\n    return idx === -1 ? buffer.length : idx;\n  }\n}\n","import { StringReader, StringWriter } from './strings';\nimport { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\n\nconst EMPTY: any[] = [];\n\ntype Line = number;\ntype Column = number;\ntype Kind = number;\ntype Name = number;\ntype Var = number;\ntype SourcesIndex = number;\ntype ScopesIndex = number;\n\ntype Mix<A, B, O> = (A & O) | (B & O);\n\nexport type OriginalScope = Mix<\n  [Line, Column, Line, Column, Kind],\n  [Line, Column, Line, Column, Kind, Name],\n  { vars: Var[] }\n>;\n\nexport type GeneratedRange = Mix<\n  [Line, Column, Line, Column],\n  [Line, Column, Line, Column, SourcesIndex, ScopesIndex],\n  {\n    callsite: CallSite | null;\n    bindings: Binding[];\n    isScope: boolean;\n  }\n>;\nexport type CallSite = [SourcesIndex, Line, Column];\ntype Binding = BindingExpressionRange[];\nexport type BindingExpressionRange = [Name] | [Name, Line, Column];\n\nexport function decodeOriginalScopes(input: string): OriginalScope[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const scopes: OriginalScope[] = [];\n  const stack: OriginalScope[] = [];\n  let line = 0;\n\n  for (; reader.pos < length; reader.pos++) {\n    line = decodeInteger(reader, line);\n    const column = decodeInteger(reader, 0);\n\n    if (!hasMoreVlq(reader, length)) {\n      const last = stack.pop()!;\n      last[2] = line;\n      last[3] = column;\n      continue;\n    }\n\n    const kind = decodeInteger(reader, 0);\n    const fields = decodeInteger(reader, 0);\n    const hasName = fields & 0b0001;\n\n    const scope: OriginalScope = (\n      hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]\n    ) as OriginalScope;\n\n    let vars: Var[] = EMPTY;\n    if (hasMoreVlq(reader, length)) {\n      vars = [];\n      do {\n        const varsIndex = decodeInteger(reader, 0);\n        vars.push(varsIndex);\n      } while (hasMoreVlq(reader, length));\n    }\n    scope.vars = vars;\n\n    scopes.push(scope);\n    stack.push(scope);\n  }\n\n  return scopes;\n}\n\nexport function encodeOriginalScopes(scopes: OriginalScope[]): string {\n  const writer = new StringWriter();\n\n  for (let i = 0; i < scopes.length; ) {\n    i = _encodeOriginalScopes(scopes, i, writer, [0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeOriginalScopes(\n  scopes: OriginalScope[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenColumn\n  ],\n): number {\n  const scope = scopes[index];\n  const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n\n  if (index > 0) writer.write(comma);\n\n  state[0] = encodeInteger(writer, startLine, state[0]);\n  encodeInteger(writer, startColumn, 0);\n  encodeInteger(writer, kind, 0);\n\n  const fields = scope.length === 6 ? 0b0001 : 0;\n  encodeInteger(writer, fields, 0);\n  if (scope.length === 6) encodeInteger(writer, scope[5], 0);\n\n  for (const v of vars) {\n    encodeInteger(writer, v, 0);\n  }\n\n  for (index++; index < scopes.length; ) {\n    const next = scopes[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeOriginalScopes(scopes, index, writer, state);\n  }\n\n  writer.write(comma);\n  state[0] = encodeInteger(writer, endLine, state[0]);\n  encodeInteger(writer, endColumn, 0);\n\n  return index;\n}\n\nexport function decodeGeneratedRanges(input: string): GeneratedRange[] {\n  const { length } = input;\n  const reader = new StringReader(input);\n  const ranges: GeneratedRange[] = [];\n  const stack: GeneratedRange[] = [];\n\n  let genLine = 0;\n  let definitionSourcesIndex = 0;\n  let definitionScopeIndex = 0;\n  let callsiteSourcesIndex = 0;\n  let callsiteLine = 0;\n  let callsiteColumn = 0;\n  let bindingLine = 0;\n  let bindingColumn = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    let genColumn = 0;\n\n    for (; reader.pos < semi; reader.pos++) {\n      genColumn = decodeInteger(reader, genColumn);\n\n      if (!hasMoreVlq(reader, semi)) {\n        const last = stack.pop()!;\n        last[2] = genLine;\n        last[3] = genColumn;\n        continue;\n      }\n\n      const fields = decodeInteger(reader, 0);\n      const hasDefinition = fields & 0b0001;\n      const hasCallsite = fields & 0b0010;\n      const hasScope = fields & 0b0100;\n\n      let callsite: CallSite | null = null;\n      let bindings: Binding[] = EMPTY;\n      let range: GeneratedRange;\n      if (hasDefinition) {\n        const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n        definitionScopeIndex = decodeInteger(\n          reader,\n          definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0,\n        );\n\n        definitionSourcesIndex = defSourcesIndex;\n        range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex] as GeneratedRange;\n      } else {\n        range = [genLine, genColumn, 0, 0] as GeneratedRange;\n      }\n\n      range.isScope = !!hasScope;\n\n      if (hasCallsite) {\n        const prevCsi = callsiteSourcesIndex;\n        const prevLine = callsiteLine;\n        callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n        const sameSource = prevCsi === callsiteSourcesIndex;\n        callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n        callsiteColumn = decodeInteger(\n          reader,\n          sameSource && prevLine === callsiteLine ? callsiteColumn : 0,\n        );\n\n        callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n      }\n      range.callsite = callsite;\n\n      if (hasMoreVlq(reader, semi)) {\n        bindings = [];\n        do {\n          bindingLine = genLine;\n          bindingColumn = genColumn;\n          const expressionsCount = decodeInteger(reader, 0);\n          let expressionRanges: BindingExpressionRange[];\n          if (expressionsCount < -1) {\n            expressionRanges = [[decodeInteger(reader, 0)]];\n            for (let i = -1; i > expressionsCount; i--) {\n              const prevBl = bindingLine;\n              bindingLine = decodeInteger(reader, bindingLine);\n              bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n              const expression = decodeInteger(reader, 0);\n              expressionRanges.push([expression, bindingLine, bindingColumn]);\n            }\n          } else {\n            expressionRanges = [[expressionsCount]];\n          }\n          bindings.push(expressionRanges);\n        } while (hasMoreVlq(reader, semi));\n      }\n      range.bindings = bindings;\n\n      ranges.push(range);\n      stack.push(range);\n    }\n\n    genLine++;\n    reader.pos = semi + 1;\n  } while (reader.pos < length);\n\n  return ranges;\n}\n\nexport function encodeGeneratedRanges(ranges: GeneratedRange[]): string {\n  if (ranges.length === 0) return '';\n\n  const writer = new StringWriter();\n\n  for (let i = 0; i < ranges.length; ) {\n    i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n  }\n\n  return writer.flush();\n}\n\nfunction _encodeGeneratedRanges(\n  ranges: GeneratedRange[],\n  index: number,\n  writer: StringWriter,\n  state: [\n    number, // GenLine\n    number, // GenColumn\n    number, // DefSourcesIndex\n    number, // DefScopesIndex\n    number, // CallSourcesIndex\n    number, // CallLine\n    number, // CallColumn\n  ],\n): number {\n  const range = ranges[index];\n  const {\n    0: startLine,\n    1: startColumn,\n    2: endLine,\n    3: endColumn,\n    isScope,\n    callsite,\n    bindings,\n  } = range;\n\n  if (state[0] < startLine) {\n    catchupLine(writer, state[0], startLine);\n    state[0] = startLine;\n    state[1] = 0;\n  } else if (index > 0) {\n    writer.write(comma);\n  }\n\n  state[1] = encodeInteger(writer, range[1], state[1]);\n\n  const fields =\n    (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n  encodeInteger(writer, fields, 0);\n\n  if (range.length === 6) {\n    const { 4: sourcesIndex, 5: scopesIndex } = range;\n    if (sourcesIndex !== state[2]) {\n      state[3] = 0;\n    }\n    state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n    state[3] = encodeInteger(writer, scopesIndex, state[3]);\n  }\n\n  if (callsite) {\n    const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite!;\n    if (sourcesIndex !== state[4]) {\n      state[5] = 0;\n      state[6] = 0;\n    } else if (callLine !== state[5]) {\n      state[6] = 0;\n    }\n    state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n    state[5] = encodeInteger(writer, callLine, state[5]);\n    state[6] = encodeInteger(writer, callColumn, state[6]);\n  }\n\n  if (bindings) {\n    for (const binding of bindings) {\n      if (binding.length > 1) encodeInteger(writer, -binding.length, 0);\n      const expression = binding[0][0];\n      encodeInteger(writer, expression, 0);\n      let bindingStartLine = startLine;\n      let bindingStartColumn = startColumn;\n      for (let i = 1; i < binding.length; i++) {\n        const expRange = binding[i];\n        bindingStartLine = encodeInteger(writer, expRange[1]!, bindingStartLine);\n        bindingStartColumn = encodeInteger(writer, expRange[2]!, bindingStartColumn);\n        encodeInteger(writer, expRange[0]!, 0);\n      }\n    }\n  }\n\n  for (index++; index < ranges.length; ) {\n    const next = ranges[index];\n    const { 0: l, 1: c } = next;\n    if (l > endLine || (l === endLine && c >= endColumn)) {\n      break;\n    }\n    index = _encodeGeneratedRanges(ranges, index, writer, state);\n  }\n\n  if (state[0] < endLine) {\n    catchupLine(writer, state[0], endLine);\n    state[0] = endLine;\n    state[1] = 0;\n  } else {\n    writer.write(comma);\n  }\n  state[1] = encodeInteger(writer, endColumn, state[1]);\n\n  return index;\n}\n\nfunction catchupLine(writer: StringWriter, lastLine: number, line: number) {\n  do {\n    writer.write(semicolon);\n  } while (++lastLine < line);\n}\n","import { comma, decodeInteger, encodeInteger, hasMoreVlq, semicolon } from './vlq';\nimport { StringWriter, StringReader } from './strings';\n\nexport {\n  decodeOriginalScopes,\n  encodeOriginalScopes,\n  decodeGeneratedRanges,\n  encodeGeneratedRanges,\n} from './scopes';\nexport type { OriginalScope, GeneratedRange, CallSite, BindingExpressionRange } from './scopes';\n\nexport type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nexport function decode(mappings: string): SourceMapMappings {\n  const { length } = mappings;\n  const reader = new StringReader(mappings);\n  const decoded: SourceMapMappings = [];\n  let genColumn = 0;\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  do {\n    const semi = reader.indexOf(';');\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    genColumn = 0;\n\n    while (reader.pos < semi) {\n      let seg: SourceMapSegment;\n\n      genColumn = decodeInteger(reader, genColumn);\n      if (genColumn < lastCol) sorted = false;\n      lastCol = genColumn;\n\n      if (hasMoreVlq(reader, semi)) {\n        sourcesIndex = decodeInteger(reader, sourcesIndex);\n        sourceLine = decodeInteger(reader, sourceLine);\n        sourceColumn = decodeInteger(reader, sourceColumn);\n\n        if (hasMoreVlq(reader, semi)) {\n          namesIndex = decodeInteger(reader, namesIndex);\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n        } else {\n          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n        }\n      } else {\n        seg = [genColumn];\n      }\n\n      line.push(seg);\n      reader.pos++;\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    reader.pos = semi + 1;\n  } while (reader.pos <= length);\n\n  return decoded;\n}\n\nfunction sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}\n\nexport function encode(decoded: SourceMapMappings): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\n  const writer = new StringWriter();\n  let sourcesIndex = 0;\n  let sourceLine = 0;\n  let sourceColumn = 0;\n  let namesIndex = 0;\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) writer.write(semicolon);\n    if (line.length === 0) continue;\n\n    let genColumn = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      if (j > 0) writer.write(comma);\n\n      genColumn = encodeInteger(writer, segment[0], genColumn);\n\n      if (segment.length === 1) continue;\n      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n      sourceLine = encodeInteger(writer, segment[2], sourceLine);\n      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n\n      if (segment.leH      æj     Ó      pŽ    ¼_§QV9Û €             < S Y S T E M P      œq    Ñ     HpŽ    ¼_§QV9Û  €             < P A S S W D . L O G p      :    ±q    ˜pŽ    ¼_§QV9Û€ €            2 < U s e r N o t P r e s e n t S e s s i o n . e t l   À      ™Ž    ´q    qŽ    ¼_§QV9Û  €        &   „ < N T U S E R . D A T { 2 e 1 9 e c 7 b - c b f 5 - 1 1 e e - a f 9 6 - 8 b e 0 e c 9 2 9 3 f 7 } . T x R . 0 . r e g t r a n s - m s °      –Ž    ´q    ÈqŽ    ¼_§QV9Û  €        &   p < N T U S E R . D A T { 2 e 1 9 e c 7 b - c b f 5 - 1 1 e e - a f 9 6 - 8 b e 0 e c 9 2 9 3 f 7 } . T x R . b l f     X      ¢r   7 ñ     xrŽ    ¼_§QV9Û  €             < E t w R T U B P M . e t l   À          )r    ÐrŽ    ¼_§QV9Û  €        &   „ < N T U S E R . D A T { 2 e 1 9 e c 7 b - c b f 5 - 1 1 e e - a f 9 6 - 8 b e 0 e c 9 2 9 3 f 7 } . T x R . 0 . r e g t r a n s - m s °          )r    sŽ    ¼_§QV9Û  €        &   p < N T U S E R . D A T { 2 e 1 9 e c 7 b - c b f 5 - 1 1 e e - a f 9 6 - 8 b e 0 e c 9 2 9 3 f 7 } . T x R . b l f     h      As    ƒ     @tŽ    ¼_§QV9Û  €            & < S t o r G r o u p P o l i c y . l o g       p      0      ñ     ¨tŽ    ¼_§QV9Û  €            0 < E t w R T E v e n t L o g - S y s t e m . e t l     €      B    ’    uŽ    ¼_§QV9ÛÁ €            B < w a a s m e d i c . 2 0 2 4 1 1 1 8 _ 0 1 0 8 0 0 _ 5 4 1 . e t l   h      1      ª     ˜uŽ    ¼_§QV9Û€ €            * < W d i C o n t e x t L o g . e t l . 0 0 3   X      Fs    M      vŽ    ¼_§QV9Û  €            < S e c u r i t y . e v t x   p      ×t   4 ñ     XvŽ    ¼_§QV9Û  €            4 < E t w R T E v e n t l o g - S e c u r i t y . e t l €      ´s    ¬     ÈvŽ    ¼_§QV9Û  €            D < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d - w a l x      R   * ñ     HwŽ    ¼_§QV9Û  €            < < E t w R T W F P - I P s e c   D i a g n o s t i c s . e t l `      .      ñ     ÀwŽ    ¼_§QV9Û  €              < E t w R T D i a g L o g . e t l     À      	          xŽ    ¼_§QV9Û  €        &   „ < N T U S E R . D A T { 2 e 1 9 e c 7 b - c b f 5 - 1 1 e e - a f 9 6 - 8 b e 0 e c 9 2 9 3 f 7 } . T x R . 0 . r e g t r a n s - m s °      ›         àxŽ    ¼_§QV9Û  €        &   p < N T U S E R . D A T { 2 e 1 9 e c 7 b - c b f 5 - 1 1 e e - a f 9 6 - 8 b e 0 e c 9 2 9 3 f 7 } . T x R . b l f     p          ð     yŽ    ¼_§QV9Û€ €            4 < D i a g t r a c k - L i s t e n e r . e t l . 0 0 4 È          Ä     zŽ    ¼_§QV9Û  €        &   ˆ < U s r C l a s s . d a t { f 4 8 b e e 6 5 - 0 8 e 7 - 1 1 e f - b 5 a 1 - c 0 3 f d 5 5 7 9 d d 6 } . T x R . 0 . r e g t r a n s - m s     °          Ä    ÈzŽ    ¼_§QV9Û  €        &   t < U s r C l a s s . d a t { f 4 8 b e e 6 5 - 0 8 e 7 - 1 1 e f - b 5 a 1 - c 0 3 f d 5 5 7 9 d d 6 } . T x R . b l f €      £r   ø ¬     x{Ž    ¼_§QV9Û  €            > < S t a t e R e p o s i t o r y - M a c h i n e . s r d - w a l       P      †z    ˆ     ø{Ž    ¼_§QV9Û  €             < S R U . l o g       €      Ðs    ¬     H|Ž    ¼_§QV9Û  €            D < S t a t e R e p o s i t o r y - D e p l o y m e n t . s r d - s h m €      …w   ò ¬     È|Ž    ¼_§QV9Û  €            > < S t a t e R e p o s i t o r y - M a c h i n e . s r d - s h m       p      †w   €Ls    H}Ž    ¼_§QV9Û €            . < ~ F o n t C a c h e - S - 1 - 5 - 1 8 . d a t       €          Ls    ¸}Ž    ¼_§QV9Û €            > < ~ F o n t C a c h e - F o n t S e t - S - 1 - 5 - 1 8 . d a t       X      ãs    Õ     8~Ž    ¼_§QV9Û€ €             < w f p d i a g . e t l       P      xt    ˆ     ~Ž    ¼_§QV9Û  €             < S R U D B . j f m   X      ~q    ð     à~Ž    ¼_§QV9Û€ €             < N e t C o r e . e t l       ¨      C    Öt    8Ž    ¼_§QV9ÛÁ €            l < S c r e e n O n P o w e r S t u d y T r a c e S e s s i o n - 2 0 2 4 - 1 1 - 1 8 - 0 8 - 0 8 - 0 3 . e t l                                 °      D          €Ž    ¼_§QV9Û  €            p < o f f i c e c l i c k t o r u n . e x e _ s t r e a m s e r v e r ( 2 0 2 4 1 1 1 8 0 8 0 8 0 3 D 2 C ) . l o g     X      l<    ð”    °€Ž    ¼_§QV9Û  €             < u p d a t e r . l o g       p      €w   Ý Ls    Ž    ¼_§QV9Û €            . < ~ F o n t C a c h e - F o n t F a c e . d a t       X      <|    *     xŽ    xboeV9Û           $    < b o o t s t a t . d a t     X      <|    *     ÐŽ    A’oeV9Û  €        $    < b o o t s t a t . d a t     X      <|    *     (‚Ž    ÀÄoeV9Û           $    < b o o t s t a t . d a t     X      <|    *     €‚Ž    ÏÚoeV9Û  €        $    < b o o t s t a t . d a t     X      <|    *     Ø‚Ž    PÙ–V9Û           $    < b o o t s t a t . d a t     X      <|    *     0ƒŽ    óÙ–V9Û  €        $    < b o o t s t a t . d a t     X      <|    *     ˆƒŽ    ¥ÃÙ–V9Û           $    < b o o t s t a t . d a t     X      <|    *     àƒŽ    ëÙ–V9Û  €        $    < b o o t s t a t . d a t     X      <|    *     8„Ž    uõüõe9Û           $    < b o o t s t a t . d a t     X      <|    *     „Ž    pýõe9Û  €        $    < b o o t s t a t . d a t     X      <|    *     è„Ž    zjýõe9Û           $    < b o o t s t a t . d a t     X      <|    *     @…Ž    Q‘ýõe9Û  €        $    < b o o t s t a t . d a t     X      <|    *     ˜…Ž    7s± f9Û           $    < b o o t s t a t . d a t     X      <|    *     ð…Ž    ;Ç± f9Û  €        $    < b o o t s t a t . d a t     X      <|    *     H†Ž    ÏS² f9Û           $    < b o o t s t a t . d a t     X      <|    *      †Ž    ÏS² f9Û  €        $    < b o o t s t a t . d a t     X      <|    *     ø†Ž    W² f9Û           $    < b o o t s t a t . d a t     X      <|    *     P‡Ž    çÉ² f9Û  €        $    < b o o t s t a t . d a t     X      <|    *     ¨‡Ž    ^³ f9Û           $    < b o o t s t a t . d a t     X      <|    *      ˆŽ    O*³ f9Û  €        $    < b o o t s t a t . d a t     X      <|    *     XˆŽ    \Q³ f9Û           $    < b o o t s t a t . d a t     X      <|    *     °ˆŽ    ù™³ f9Û  €        $    < b o o t s t a t . d a t     X      <|    *     ‰Ž    _ê³ f9Û           $    < b o o t s t a t . d a t     X      <|    *     `‰Ž    É
´ f9Û  €        $    < b o o t s t a t . d a t     X      <|    *     ¸‰Ž    :w´ f9Û           $    < b o o t s t a t . d a t     X      <|    *     ŠŽ    ÿ›´ f9Û  €        $    < b o o t s t a t . d a t     X      <|    *     hŠŽ     µ f9Û           $    < b o o t s t a t . d a t     X      <|    *     ÀŠŽ     µ f9Û  €        $    < b o o t s t a t . d a t     X      <|    *     ‹Ž    †“µ f9Û           $    < b o o t s t a t . d a t     X      <|    *     p‹Ž    ÈÏµ f9Û  €        $    < b o o t s t a t . d a t     X      <|    *     È‹Ž    
¶ f9Û           $    < b o o t s t a t . d a t     X      <|    *      ŒŽ     1¶ f9Û  €        $    < b o o t s t a t . d a t     X      <|    *     xŒŽ    €¶ f9Û           $    < b o o t s t a t . d a t     X      <|    *     ÐŒŽ    €¶ f9Û  €        $    < b o o t s t a t . d a t     X      <|    *     (Ž    õ¥¶ f9Û           $    < b o o t s t a t . d a t     X      <|    *     €Ž    æÌ¶ f9Û  €        $    < b o o t s t a t . d a t     X      <|    *     ØŽ    yÃƒf9Û           $    < b o o t s t a t . d a t     X      <|    *     0ŽŽ    ëƒf9Û  €        $    < b o o t s t a t . d a t     X      <|    *     ˆŽŽ    Ba„f9Û           $    < b o o t s t a t . d a t     X      <|    *     àŽŽ    ¾Ô„f9Û  €        $    < b o o t s t a t . d a t     X      !            8Ž    chÁf9Û                < $ T x f L o g . b l f       X      !            Ž    Ÿ½Áf9Û  €             < $ T x f L o g . b l f                               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></r:allConditions></r:allConditions></r:grant><r:issuer><Signature xmlns="http://www.w3.org/2000/09/xmldsig#"><SignedInfo><CanonicalizationMethod Algorithm="http://www.microsoft.com/xrml/lwc14n"/><SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/><Reference><Transforms><Transform Algorithm="urn:mpeg:mpeg21:2003:01-REL-R-NS:licenseTransform"/><Transform Algorithm="http://www.microsoft.com/xrml/lwc14n"/></Transforms><DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/><DigestValue>ww5DYGp6ClcRJgeGif0RDMTjrOw=</DigestValue></Reference></SignedInfo><SignatureValue>Cf5S52J4bzTyn97Pk6yLnxCxHApIs27bIthDI0Jot6tVfidafXJivdvegezXzLjuvYihGlZd4XnOwH64C6Rcbk8udd5mFhSxxfn8UFs71t9jbhxNFOPqdFqi18sNZdrnWlKDDwYOynyb5Q8JtiOHIoTZIKmb3J8ZFoQ2mdVEC9aef4d3tZ5OSiw6pMegZTiET6k9y/HfRfs0PTUcx8alKbwuKX1SlMv1aFhWUYgqKE+/PSid6GIxbhIhQ/dBGxrPf5m667NqDl4O13SmdGUvsR/qywIpI35M4RTX6s4o5SIy130ag+lQLDOQ9ET1Iag8MHoDggI6WT8+c2+KmjBsXg==</SignatureValue><KeyInfo><KeyValue><RSAKeyValue><Modulus>tajcnLtdaeK0abuL2BpVC7obdfSChnHAx7TSn/37DwbTDegkDkEnbr0YyO/Q5Jluj5QD897+nWW54RDbYYTdNgWjyUpwYEJFXSZtd8LFK2mbIjKfG2HIShp6JJARlrgObR89a1EH716nP3PbJk6PWQa6VfjBzPQUgSVywIRU+OKbnzNbUVmQ/rAN6+AN/8fRmFhyKqOAiV/Np2jBtGNxLXm9ebMdm5cB8/YNrjp5Ey0nyAtYvovb0B7wnQZfolMF+OFiqzWJo2Ze0O7WHsWBHtIlGR3+c/IjxUJAsI7O3U4hncCZdvlC5GORI2YL9YHZgU9guSPLhAybQ3IGg7LBuQ==</Modulus><Exponent>AQAB</Exponent></RSAKeyValue></KeyValue></KeyInfo></Signature><r:details><r:timeOfIssue>2016-01-01T00:00:00Z</r:timeOfIssue></r:details></r:issuer><r:otherInfo xmlns:r="urn:mpeg:mpeg21:2003:01-REL-R-NS"><tm:infoTables xmlns:tm="http://www.microsoft.com/DRM/XrML2/TM/v2"><tm:infoList tag="#global"><tm:infoStr name="licenseType">msft:sl/EUL/PHONE/PRIVATE</tm:infoStr><tm:infoStr name="licenseCategory">msft:sl/EUL/PHONE/PRIVATE</tm:infoStr><tm:infoStr name="licenseVersion">2.0</tm:infoStr><tm:infoStr name="licensorUrl">http://licensing.microsoft.com</tm:infoStr><tm:infoStr name="issuanceCertificateId">{7e3094cf-ce3e-4ed4-8c8c-20c2be1add03}</tm:infoStr><tm:infoStr name="publicCertificateId">{9a8e9b84-8862-4fed-8ff6-d01b75904d28}</tm:infoStr><tm:infoStr name="productSkuId">{30a42c86-b7a0-4a34-8c90-ff177cb2acb7}</tm:infoStr><tm:infoStr name="hwid:ootGrace">0</tm:infoStr><tm:infoStr name="win:branding">161</tm:infoStr></tm:infoList></tm:infoTables></r:otherInfo></r:license></rg:licenseGroup>ªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªªUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU„0   bÅî=e«Š~Ün,ñ;Ø°ÞÞ‚ø‡nßôÙT§ï‘™   X   9 a 8 e 9 b 8 4 - 8 8 6 2 - 4 f e d - 8 f f 6 - d 0 1 b 7 5 9 0 4 d 2 8 _ - - _ m e t      0   F a m i l y   P r o f e s s i o n a l W o r k s t a t i o n   4      P r o d u c t K e y G r o u p U n i q u e n e s s   W I N D O W S 6 . 2   "      U X D i f f e r e n t i a t o r   V O L U M E _ K M S      J   a p p l i c a t i o n I d   5 5 c 9 2 7 3 4 - d 6 8 2 - 4 d 7 1 - 9 8 3 e - d 6 e c 3 f 1 6 0 5 9 f      J   f i l e I d   e 1 0 b 5 6 b 1 - 5 3 6 5 - d 5 d f - 5 5 1 5 - 4 c 8 1 e 0 1 b d 8 a 3         f i l e I n d e x   0         h w i d : o o t G r a c e   0   ,   J   i s s u a n c e C e r t i f i c a t e I d   7 e 3 0 9 4 c f - c e 3 e - 4 e d 4 - 8 c 8 c - 2 0 c 2 b e 1 a d d 0 3       2   l i c e n s e C a t e g o r y   m s f t : s l / E U L / P H O N E / P U B L I C   &   J   l i c e n s e D e s c r i p t i o n   W i n d o w s ( R )   U L   p h o n e   L i c e n s e   ( P u b l i c )      J   l i c e n s e I d   9 a 8 e 9 b 8 4 - 8 8 6 2 - 4 f e d - 8 f f 6 - d 0 1 b 7 5 9 0 4 d 2 8      2   l i c e n s e T y p e   m s f t : s l / E U L / P H O N E / P U B L I C         l i c e n s e V e r s i o n   2 . 0      >   l i c e n s o r U r l   h t t p : / / l i c e n s i n g . m i c r o s o f t . c o m      (   m e t a I n f o T y p e   m e t a I n f o T y p e L i c e