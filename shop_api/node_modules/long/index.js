/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

// WebAssembly optimizations to do native i64 multiplication and divide
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

  /**
   * The low 32 bits as a signed value.
   * @type {number}
   */
  this.low = low | 0;

  /**
   * The high 32 bits as a signed value.
   * @type {number}
   */
  this.high = high | 0;

  /**
   * Whether unsigned or not.
   * @type {boolean}
   */
  this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}

/**
 * @function
 * @param {*} value number
 * @returns {number}
 * @inner
 */
function ctz32(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
  var obj, cachedObj, cache;
  if (unsigned) {
    value >>>= 0;
    if (cache = (0 <= value && value < 256)) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache)
      UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache = (-128 <= value && value < 128)) {
      cachedObj = INT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache)
      INT_CACHE[value] = obj;
    return obj;
  }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
  if (isNaN(value))
    return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0)
      return UZERO;
    if (value >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  if (value < 0)
    return fromNumber(-value, unsigned).neg();
  return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
  if (str.length === 0)
    throw Error('empty string');
  if (typeof unsigned === 'number') {
    // For goog.math.long compatibility
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError('radix');

  var p;
  if ((p = str.indexOf('-')) > 0)
    throw Error('interior hyphen');
  else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }

  // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = fromNumber(pow_dbl(radix, 8));

  var result = ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i),
      value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
  if (typeof val === 'number')
    return fromNumber(val, unsigned);
  if (typeof val === 'string')
    return fromString(val, unsigned);
  // Throws for non-objects, converts non-instanceof Long:
  return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @this {!Long}
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError('radix');
  if (this.isZero())
    return '0';
  if (this.isNegative()) { // Unsigned Longs are never negative
    if (this.eq(MIN_VALUE)) {
      // We need to change the Long value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixLong = fromNumber(radix),
        div = this.div(radixLong),
        rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else
      return '-' + this.neg().toString(radix);
  }

  // Do several (6) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
    rem = this;
  var result = '';
  while (true) {
    var remDiv = rem.div(radixToPower),
      intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
      digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero())
      return digits + result;
    else {
      while (digits.length < 6)
        digits = '0' + digits;
      result = '' + digits + result;
    }
  }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @this {!Long}
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @this {!Long}
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @this {!Long}
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative()) // Unsigned Longs are never negative
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--)
    if ((val & (1 << bit)) != 0)
      break;
  return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive or zero.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @this {!Long}
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @this {!Long}
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @funcHÀJ˜)30qB˜á¡PZÃù´HËS"ÕÒÁ.F”4§Ú+¼îH¬õ§ÉÀ˜Ò`Ò†fm®õ-ƒyÄ®r8ƒ×–ù&WìÜ°ŠÛòDnÃ[lÂR_l‰ÄéR¥N¼qæ›¿ï³Z»XîÂ¡†ÿñÉpXŒë¬CqhR´(¬¥+åÏ·zödÛ.œnKÿL‚‰DoŒÒ‡Iìñã æÕIÇ/Ä  z…÷H†¡¼î2¤67¤“êİS¨c¬“hNë<÷&»U•”j~¨aê
	˜j`-“*Å-wÊ²7¥:ÍDsÌ®ù´\ø\šÏ¦ù9ï t‡®]p\ùC0çC^G“f‹úÖe×¬§ê~ù«<ş>¯mÛ¬IØM|
*Îc¢µÔİ˜ûCå )W¾ÇLHÓÿÜÏş"uŠÙ9»-Å—cöp5›©¯2Æª
ººíc©Œ¡Ö€ùaµååóøèpt}şP°åÅ¶rÖm›\í°â“NeØ#¾übNï¼ÈãtÆ(í,ùzØÖüh²gÎ™N}ôzvp	ŞSèİ¼¿İcÅ¿ÃfC¬ØË?2¡=oìSÈúDÚÍh¥;ò=‘2Rù¤Ê ‚®Á5Öå
€7÷©×†-ßgÌ‹½F/š‘jjáj3[&´Ğh¶
(‹:ï‡)KÑéK·âk/ttÒˆZ”7©8>0”enò#x hbN¦÷–SÒ’é¿JHDœ îšÃù|Ò:Í¿§&9½²4c˜†5°Ù”ÚÓ.*|i—»Õ+‚XJ™§–}\^^_ w»ŒFÆsv¸²(­Ÿ*Djl—=ãO¬;«¿†ßm=”çWÕ›ŒúX?ñ,Ñã©—'Û~ÆoŸãürdF6İ5‰ğ;ÆB-ÜdOò˜­	³¢&m£_`™áDÔí&÷¦Â%ÛKn'ı3’Ë+½‘æo®Ñ³C[‹CØg£ÚF3¦ç@ÑÜPìN`é>Ï$ù.«ĞTàJ‚å/¶]Ş, €Ñ¥»3¥Ñ¢vU°cG&Ã%¬( Q’GêƒCµ‘JÇËÇ™‘F^ÍáfiŠ#™‰WÒ¤;`
Mæ`9ÍfL©Y ÜëoHpwuÕ‡™KIÊàsk‹ÏÓoAuÕ¼ĞUoÃÉä\æÔ´órJ¦eXAìl]»˜.Izç{ıò¼Øß¡}
¦"ÓñhßjGÚC+Y©¥1:³Ï|e3µ°t
¼J¥½Ùxqôg‰ÔsëwÍi·÷níÍo=ËÉõ=§¦5ëÕk6ÈÿT]V¯v0
XÛ7'_ÚåŠo‡Oxÿ¾dˆ
Ô6ÕƒÏ‚Y•$¬òò—Ù†¡‡ûı&¶‰Bh¬J
}Ø\?Tµª`Uœ%]°Îè¶±†²\8ı<áÈÚ¬Æ0LW4ş…›õƒnˆ:‰È<—~ÆÍ¦â§èş´t¨ç9Ê¼ìéØa8'¹†º½ (åñ¾ (Ep8 ç±"8T‘ìfOCTaºç„M8ëjµÆØ3“n’M[pÄXıïßó–A§TáRm²<%V‚«µT¬Çî›Y4¼‰‘<ù±Ø.YAüU#å_F]Ï– ³À©ÏæéæÚ€ísÙG^6üãX{3ÏV­6Œ`Ÿ³)›Q?>ÉMü´îÛX6%È…ª7 ÏrFì—Ğ|ár 9QX×ü*KÉŒ%ˆ)»p›ĞàqĞÛ·âY¶çùq>4Oİ´’üĞ÷âÎl;l~:Ó ½ç¾HôkÌ·ëó>†”UULxÂ¾†>/b¿ã×İ>¯i©'û¥e¸`f=˜ç&˜îæ¢_Š‡BÈÅÕ	¯¢­ë/Ïz‚İ†P¡Ì:$¶Ô(~áÅÆH5Ì36‹°”Iq1¦!L<¹u">,4©Œ/ïo·à
Ûsİ±/ÒEş7i¢üGOåı`ì65É«wwnıZÍsÿ(”&Ÿ	{g!Z†lD>îXƒéáîÍ™KËğ±íşœGK¡ôøQ×5.ÆÔÌÀüğâÖÕãÀşş¬hÜ[uØ6gûà,¹×÷uÊ=m/v}-é>*»šĞ«Ÿ›‡ÙÖ;ta,Êë}ã_yµ’Rgó‘Á"‘03ñËû¨]õS€¥xùeÖ/à‹eDß]À~î+şwá›íåñ1†Z Ş)ŒÄ©æ)£ã”ešä0ÜÌdò%FÔd"óOüV›_ÍWê~Qvïô*ÿ´0H<” ‰ø_thóù6U‰6Ó:½E¥¨©QN´Ğ‹D*ƒÄÙWHåwO•HY(7ÎyÔÍğ¨¤ÄºèÆ(‘_c(ATÃı‚K­ø­Õ8™gÜ*É.LDFÿ~F£KÃ°cÕìíæ®–¤øíŸsüí„Û]çÖ¶ëÚúxÖ0	:³ü‘™nP§ø4àĞ3“µWìE3XltN½c±ƒÄÚ×1âåaU¯²]… {j¿j‰òæ„x³–{wZ±YÚb>ãà¤”#¢5õúK
Ök¹­Z¯½~]vÃcÙ	Ü4¼I”Ç;Y#¬˜ëÓ	RÁMC]heT¼;…ƒß+Ã^ŸRmê^óM$’ûI&¢pgtã9÷E£—±—^—ë3Aoä+°ã›IHøƒ0¥SÙƒS²L,jÈã`Ò‡å$$ê°,TÙ
¶;ª˜ƒDvFQÎ”Ñ™Ò§O‘0tâçÉ7‚Yƒ­ÃâYˆ@éHP	ÎµÆüfG<f‘º+ˆTÇTXŠG×Ñg¢.¶4É	B™NI¡]òj¾IH‘ğ7#€ó6å¿n(eFP–Ò˜^‡/'¤1şüç²;¤‹™|Šo—vóş_‡‡è¹ı$ÈTªò%HÔ¯$s´ÀªÃLí¥·pg8š±BÄnm>œ—YDIU(ò…>Ø.µˆ?9œì˜Hg ©Æ{YGL ]Zi-û÷üiâ†›,ÑóeYéX¬WÓ5k–½7E‰Ô:XB–u—²®ì>eÁ¨ÁİŠòZŸVyä3ßÍGÇÌ“MÄëBhœ_>ÏEÔ½÷bıô¤¢Ò-.æ¥à\ôX>RâäßAÙ-çE›§ÆŠL({C¯¸ºkud!åÇ~°Òòüo¨ °ÎÅ4«OjHhUÍWW.…LTkt6ïU¢OİæSú:ÚEV™ß¯Øù§UcVæ±jÉÕÓ…V;mÁë•NW´•9jFœàâªÌ‰Ñõ¡­™yW5—ç …Sb×$S}?·K·2–3xŠ®ó¦ÿxÅÕ1>ÏêÏ45;0o™ÓrŠzöû®U»±´Ô$ÑŸFxl*ãæ3K½Z´ vÍ«lQ?½Ï¯TúçßF÷¹ìF.×Òğ(=m="ñ.ÁvVŠ¦/{ñ™äÎ}pÚNz‡r¤tKÈ•dlŒ˜}?FÀ]Â˜h£¡#ù
HmİÊŞs>mmK]ïå>
I‡-BKYÄ%k"Ú÷Ü‰`>y	FÅ¤K$„
ªÇ+ëÈäKÒË:9GqÄGùpGîde´f8àß
ZÍäêÍAôÏ±LÃ_…è>HEjœEdƒ2vâ"_CŠÔ‚JM–‚'êf² ŒyWNØòû6ü‰Ø¨™Õ+İRè4Vã”‡÷”JrŒù®N=§ÙšR×¥Æ­:PäŸXÀZuXKœ¦ÜEy¡™z[MRÕ¨b=eßñ§Fí¬qYÖ+£í–Ş}ğÓ…wÚ­>æxòZ½‘sh"(ÁSS<(/r—3©ú;uµ[’²İHñoNô@VP$6""Ö$ª-”JÕ!qˆ¼´ñúÛÙ1µÖ™ÆÛHÏ'çµÃKÌbµDUED¨üuzëÍa(9NÄğª\=âˆªëwäwÜâ³AV{	€Dî*v¤KC›ë"Fn_–"¬búÜ\3ŞÍ¹GDŒ›Ê2rKÚ$ZcÈ¶mrÈS2B£DÄÜ˜ƒÿË_o%×…Á¸øÕY¥z\N­Í3×y@Çïf8+^öü7§Y¦¶·Cyr>ÿ…¿ui.Ã?É(y¬àà7wÅ£rÃÛ¸ËÍQÔÔhòF|¥^ö&~W+æK8™jD­,m‡7*Ê‚¦§³	Â¢ûöG—/ÎO²¦íûH1®râ®}bq¯‰Úó¾ÙlıC‚{íaÜIïºr?éD=Y¦Pİß(átÇ¶å7vÓ‹ı¼„¢‰4ôx©CUÏ2÷Ó­c½w?@GãJLÒÃê¯d¨µêß·¤ïuÆ»P üôƒ|\¯Ğ«³ãúh)^ÇX°×C
İ&z]çzwFnÍ¶ì‹‘îv´éÍ'Ë-Ãˆ˜Ìµo
.ÃCÒ- =È«g--Œ,÷3œ5oÎTk3lhŸ+µnj7b",nÍ¤wœ¦Åõ÷ŠÖxÂ›´çÈÑÊá¸•²{^˜wòà¥‘
9ŠZ]o±¿ıÉo¾ÇÛ²ø±Ñl B÷v¯vóÊ¤Ô[û¸Û„nTlnú>\†HÿK`¼§øŒ)ÿêîüÑŒNº–Ç¡Iä]²ÒS.;Š)|¥aú©M	+ÃÁ´#Pº¯æ8°ü)iŠ£RõQÍ¯cG~K¥y,j”Ê¶1~1…ÄX˜b?NÅv‹Ol»¡¶€µš’Q’ˆèî¿ª¢ÍVÙz[“àúˆT ßÔ¼Ö€A¥ÎÀ¥Uâ‰Ì ùàb4!W"<I›Ñ=¥´ÙH`ÿ½xwÂG%0MÑ4Œ8eC86¯Ê¸~‰9íÁ78t!$¡±7RÒÄ7QXö.P¹«pâÙE?Ú‚áÆrïš‡;áñKs@ÀZöL~«Û7íñµHŸeOö˜aŒels·§{öP¿ûcÜL/¦Í¡ª†JKáLJK}ZòÅ«¦3Ä´Š®2É¤bFbò£Hj3õxO€úìöRzÆ¯]€2¼ó…ªH¼_ëê.Rù™|Ñ¤ª×„P2„gZŒóı05´GD©d'‰‘j¦;óé¬ è?İŒ%‚Šx’ËkRr¤m7VÌoè

sr­•TH”
‰ ÿ`EÕè8Ë{Ş6©•wVÎÈV“&*¥h¶€‡¿œe¡]ÚßM¿Ï°•l8Î#Zö71|¬±÷ôX­Pë?F»¥Š­ánŞÒ·©ƒ¯œñ«:PÔ’Æ²"ÙOÃ¯zsJ•"®ü`~ï¶Oã›õµ7t›yöcpèÍ˜R¤Wvá™Ù4ÚÍêµÈ
jjN"$¾I·õt?õ¢›S¬èÖˆ	Gõéñeö»øê“`iy³r<õx$]Ócß¢éN¿fopd]Ä¤<s6lİ'¹\_—±¶îíşJH½Ì9lcñ_„(Ã‡CãäÆÑ¦`Ûy8G½ŒêÜ4EQ—€1¥ÃX´â|h Ñ?§E„=«p5Ó˜r|ìÏ3œ§Û³ #ób-‰Åhöş53ÈAoÿu¦kÏü5Cìr.$ˆcT•÷@ÃíXn¿f€ÏìvPFâ8ßw©÷ã;"#k„Ëg6S²V^1¯/Ë«uHËÅr\ùâÅ@¬ˆ¯ÎôOPRÂï<Qæà„ï6H:Ê“ í¿ °TAO„v8 [ğôŸ~O~ÑWó1ËÔ½½ô¹“[²{ğ¥h¬9;îÉ÷Ã®Z+iz–/'mñÉõ·Fsßµ5%¦o×ŠWI(Oı"·,c.Ç´Î0ì¶ôÍIö# @P>kd¶{:Pko½6#^¦0:lf_‰ß,{§ÄáìÊ¼Š¦×øn¹òüÎ\QÆXúuyˆ›sú­Dùw†Èr…Py×ü 0¤š‹Fu"°¿Ja!FÍjº–6+‡ïYóœ5àTÃXõúy=Âç|&#E(’8òD‰Kf¹Ã,4f6‹o«9G®·­"K•ØSO,ÔH&ì¶ŞÉÇ°ñœ÷oYn)ä/"Ùl¿°µ~¢€î&\Ú«Ÿiœ÷­CXÂªy¯æ*O.œ`Ó•n{ÀéIñÑn¡T²YzêgÜÚî™ô9àŠÒóÅ+•Ìé‡°k—)¡©vÓ¶1Y‚üñáÓ?69¢§Å<âcä §gÛ»¼#Üğ`ˆ;˜öˆzd1I°1sõ€z`‹"9ªŞ£Hİ¤U/À •'—ZqOİ&§İı<8³@9‹o=}ŞcÅ5¡+£ öØ„E<j2ç,Ñ·`XrœŒ3%x%W(µ3å³@¯ä–&¿f[„6ÀœrÛ £g	úh"lüÏBäßCÔ5üÖ•ÃBíwÿ\ eÁ?@.ò
‘ÔÑÏpSâÿ¢Ws Eóáûd×±3µ“eãgçğ	”FÛ@³FPFúpÈ˜‘j!Îı‚«Sju«bK¸–åÌak÷™»Ä X’^at<c&Æ…Ìqµyãwıõš)¸)\¢ññ>ß|¾]Tš×£C[O]FƒÜdPSh{%K¬’3'u@û‰ßæ1ç¾÷]úzşj¥ÙÆ[B¾2%…ƒì’ÃíÕc,t¾‰R¥ aİq§˜Â±êC5vr³Ö4ëá,4úÁî#z Š£·ò*Øˆ¬¨×DÊ A%jÈİŒcÙĞ’ÛîêÆÛlÏÙy÷àr{Ó€‚ze8CŸğ!ƒÏöò_“A~¸IàMTœî"DkïÁ13\Òn†˜Mæc¦’B¼N´àä™;	ÿŸ€ãÖp>­÷ÁhY„ì¸p<bd‹)08¥…KÓÓ\•wß
«L×¸zì]…Ûã£ëL6?`[å²Mş>b‚ôtúˆ³•÷­¥Õ•ş(E9 Úhœ$l—P‚çdÏc­ø+«çm“ZTt¢íÙ¾äo½«X¢}:ÿfìŸµší‹	i‰»q€ùú½–oc|BzBñå³¸ªºë^¿^‚pR^}Ûò¶tQ	s‡› ôab·6R—7G¯v$ìËU(æ=¹ŠÈ°Œ³æå6ÿ·\FSbmE®^/ ³¦³µ®Ñ	®sGñ(Ìª_÷ÕéA$ª_Ÿ÷ù¹”ı6%/‡{o ü¯d’ù";ÃŠÜºØ€	ƒ´:j)t‘³}Ú"â5Z ‘ï®’úƒBûIØi™´òÓÄœO†hTeÑ‘ü¾D®!Œ`ÅŞyÔ†üFBL°™ÓË-XSh´Iÿêôdè!dfr²Ábz%æåŸ•üm3^’e¥Ïá»ì­»§Ì9Cúr^G½î«Øößk§“Ñ>÷Fú3/ÜÊ:“âD—ğ#ŒÆÌ$æx³;#ğ[pçä´ÆÏÏA‚ãšğûÕ-Y}z*	Zïè=³ózö4H”­96¡¶:õ÷‘Ë§k­éU|Å7tíŠçf	¢æô¸©ıG7Ë_µœßßDr Ûß=pEo#¯Şib¤?zàHåñR ¹Å„µè"…
¨©ôÉk*Z¾«x#¿)	UIeÄ*	P‚°T*Ñ¦kÜ;FŠC˜—un°ÛääÒğMì´ş1/÷Ÿ‚Ï"4µ»m²®¹'Hy²'òşì¬Æ¥÷ä—á¦Åõ=¾ûê¯Ÿ,t<xØŠ;D	Âóş¸
ÓØ¨‡¬{³ÀAË…#×]¯±2_è“_{
Î®tÙ˜'?O†;Ú]§êßØÒ°Ç|aÌ¶_ }G¼UŒóc/óŸª¾öü,'R¬`„öóºuùûf2ÃÚ*OêZh`[9÷¤\ÏóÇ¼B›˜E3!£¶¼¼l.˜ÚˆÙx5z+î¥–Ñ˜_x^eê_/‡jP_çw‚îÉ—_¯˜ƒÖá-4*ÙŠ9P_À5“ò_É²†jUÈ]¤İ1Öé)kåæó|%ıÌôlGô[rE³k"°ğ:¹ñ‹²`â]wÑø©e5[‚„’áÑäÃ¯äè¾Ê9'¤{*Šƒo¾Ş0’›â®cCò›ö¹ìC]’€bæ°iS‚ B^F–*çNÊJãâ-tÄ,vÌ|ø¸‹¹9_5v‘cüÃëÄ€š¹¾t¹Å4ÀŠ’ _•ˆ@*‡`r™â0hÀ6“É/My(ıöşï´”Æí^Në–3WIÔ>8àÑR€d©m@ÁÉíó[î¾4!. ¾|ÌTÿ€Èş¸Ğ¸^ìŸåaIØ	t ùŸ€†CF™+I„/¤½¢?k…7TM•ê¡wa‹˜<5?EB©¤U™viu±o¼ï	
LCÆıÊê1%‡i%£ mXÃ\qË¢?:…¦õr©ÎeÒ‹ËéM@á	ØX7j)Ğ–¯1|­¤Úš·5`"ÏÌÊ›
¬ÕéæM>¿ı—´z±I¬¾	"³P­$ä-kz&ÀE'é¬²L@ÊÏÊaXú!‡-˜êÔjÒ~msF³è«Î*ãcê£¿–æÇëåç’É¨Õíßò&Ş_o¸	ÁÁïİ$;vw?8ñˆıå^¢E·±?è=éš—¤µ1ûúèÚì¤ÀBòì°ë*£Œï»ƒäQ`e|4°Ş¡Qz’Ìø]¹À^rÜ'}èA/M4%¥a‰¤!>KşË    ‡xˆˆwˆ˜ˆx‰—ˆˆˆ‰‰‡‡ˆˆˆˆ˜‰ˆˆˆˆˆˆ˜ˆ‡ˆwˆˆˆˆˆwˆ‡ˆxˆˆ‰ˆˆ‡ˆˆˆˆˆ‰‰ˆˆˆ˜ˆˆˆ‰ˆˆˆˆˆˆxˆˆˆ˜ˆˆ˜ˆxˆˆˆ™ˆ˜™˜˜ˆ‡ˆ˜™‰˜˜˜ˆˆˆ™ˆ‰ˆˆˆˆˆ‰ˆˆˆ˜ˆ©‰™ˆˆˆˆˆ™ˆˆ                                                               Ğİ       Ğ ÍÚÀ          ÍĞĞĞÀ                             l9
‰ää
%qzØJwµHPP‡(«ıtç"JoØXĞS}óÊ6rpI|MDŸou¬¥L%§ÆÑVcœ­¢ĞáQ
Hf$!%5€  ¡ÓÂ°ÍŞ³+Á`K2òut£‹C&Of©šìŠJo¤@p¨u©î¨Gs@`œ¼Oş©M}ùB)Æ§_Â@û=ŞÑx»¡UW¬1û†©6¯Ï…G,J‹˜­cù5Ó]!ÍG5²ßíq«+ <mUô%kóÜrš†Æ±³î¶5DÄÇıÎd1¼QZúTl]~&â•>Ôé›EÆ×Šô#]¬úÏƒ;3ô	HÅ1àŠlÏ§Mo)l‹ŠnüUà€"ùJ<½Åác¿ËÃHİ¹}=)ˆ]JÇa¼?}sø$;>¨Duylnl8X.ï×ZÔ[<Ø/6L4Ñ5‘ı,ªŠÅ"¦ñ×-±Û¢a8NĞ­X‘LD½Eå…=l2lõD¡ÕÃØcûdÀœÙÒÿA@ó? 7KÂ«?¢àÄ‘©›X>ÛÔv~.û4”èMU|Å¹’sÛè+½¤á¼00cwçÏŸÍ¹ãÒ\¿€<àÑ%º0[ğQ#h/F|7%É—ÕÒ]}°¼q‡mşÖÚ°O–İô õL¹@ê–.³ØÀ!°¡úGÙ(vš5Si\gôq»ú7şnèİÜªlO/2ZdÖ¸ã÷Ş*ì«òåWCÅó¦ÖŒ›~=Ew2e¡İèªTìä‘ö€2TŒeâŒã…(*k»·ibŒ*;ôÛl¸‹§ø`C¶¶»D3ŒÏ‚v¸$‹‚Ñ"›1n êxM¸·ş”güˆ-Èâl°ezq=!y¶!9®4—¯t³uŒ¬"ŸN_<}‰ãŸûi´ê¶w'*€Jb»Ğ©é`ÊØmµÛK< ô»ÆÍCäö’Êò[òu\ä	(Ü´ûÙˆº¦rÇÚµå©w³ÒĞ-û€ôxJç2º¦fÏ/ºÑÊå×Ó‹æa«Eÿ	p¼Ìôù¹â8)ö1×ì=6NW`‰…,ªËbÂˆĞZe%Ì‹Gœ Yš†{÷´!Ğ>qqæ²^µÕ‘K"tcõ#!}Ôén±PsÉZJ,ur:eñ%±É³ŠIO#XpY+ç*uWçÆW±7´¨Ïí'åù&HèPÇv–|Y4m¯(<q‹ún²ì¾z×äòL¿y<‚&ñcüÈ*ôŒyÁö“ù+ )ü¨Y°QN™vãÖGÖX§¿­ÈÙÉ×ç_ß#?ò½g5Á¶zú‘¥èóE¥FLŸYÂx²ù-·óMÌßBD•¹Ğæz»ÀF¨–Ù×ª¨Šºü{Æ¶Ÿ»§È®Pÿ"]5Y¼å!Åiû‰ûkBF2ïS·ØqÌ4¢ïè!¨BÊ¨Šh}]Šë¼HÅMç`‘=ú[F¥ı?ê»!~¡n4TèH'8°'ŞÆ»†b¨ÇÙ¤C®Y¯cşe]iüùµ8H¨@0*¬Lš| Õrç~L’Å´.^Ë÷]–s¿ªÇ~ÇÜkOã(‘‡à·JHÊu”¾ÂÃŠ­-Ø¾ZTVqã£‹]: WJä@ĞÖ9Â¼énËk 7irƒ÷ã1
1ÌŸŒ]^Ô0Çı³’üzáTAêŞ‹|L^€çe|°[ûü€Wö¯Dù¾\Ğ<Ó¤?}¹kî*Dõµ¯á«Q—ú¾7‹cğ„¥Ç)ÖWûè¥9a4?|S`ÀÉª"õW†šĞ#DõÕà˜,‰Ú[Œ8µ)³ìé™Iß?—Œ‚}Iù.[‰LØ}ç/~}NÉÚZ]S²Z	&o5Ë¾÷oºâ§pBkb ÿc•ó™²,¼>ñA”d£n­‰Dÿ“Ğê×ûë%x_JÈ–sÓéİºW'1 øUêŒÜÆ[…:9…ªc®exÉ[ë°Üf‘3ó,yJàÆÉ9<f`¦.¶8ägZ¼K[\_%qxÜİ3êôBf6Ü8çw:z"ãÄı³«ÇºèHdê&óç¥]ÔF§>µXG"˜|¼Ÿ3àÃîbDe&HaÇ˜ı}ÃŸ]6ÏIÉÁ´âdr¥q!·ŸJÄ-‚,ÒÅÍùåÒõ¦@)JåÁ‡è%Õ2Ï8 Äs0üô©À:J=Íw;{Ìõfé‘Ì“®DØf}¸N0b.æ(DEo'ÜsÜk¶¨?*I@ÉYÏş|7i'4`é2Ø X¯ÅL $#O_D¿½qÊÊ!×h##”&y’Uìo$˜Y›ŒHm%."D—×š˜Cš(­µÿüÃÃklvóKzîcÁT´v³%M[VIŒ;ñ«Ìï LWœ@n] ºj×{«/S]Z’!ZÑ}sÙN6½u™À½W	®—_³Tš¨Z”f,×ĞåøÑ(É•-ˆjWşa›Ş…å?s¢7jïÓprÁÍiG÷uk³›ÛÒk4‚ŞçàæüAó–ò1zÄu‡”1LÑŒtâYwn?ÍV ³{ÒÆ.¹Š«¶Ï›ÒùäŞÏêº“½UëÍdëp‹)ìÂÃ$˜.å&6S„>OËuïÈÈdè jœ^»DÍv.%³W~‡,»rğ;ƒ®'3«Å»çÁôã¡ñK¶j¸}ıv'W3tìxŸËÑŸ6’ëo='Nì°ûß
õ¡ÿ« ¦çt¶…\¨Ú%07àëƒkHq®aUä’uş
lï@b”bË×ò›…ÏoñTI•ä“˜u^Œ/¤Dpx êŠØ"á ÷h‚š7ğ®aÈÑ@S˜¾MyrÈÂÉ²à ãW¬Yf/ògà!<Srdˆ"|İO‘-Ôà%i"àn
T¾/bV'ªrS>­•bÙ—ò¦Q¤j^)JÖyÚ{ßëSç"Ó'ştûÛôl)Bˆ7D¶˜Ş±rèùxÊ8€^a¬cÕÔ_º¨Ø#ßA#>o1”Ë™í{ÙŞ!·_‹ñ‘“’"Š $Ÿ©büZNVìÍæC§”Oİ¢÷Ğ£ø™ïØ÷zã1®UÚ·x›÷q÷ìbT
Kél¢ôŠ£É†1ˆ®Ô4	e$4?v¾V¤Œdà)fúéˆ ÉıóÄß,Š5bBQ£J=lsèÉ™@ƒV.ØeW ¥TsÜª:8S˜˜ÿd\øÎY é!&§"[ìÅó{¤w(ëRZ€I©GxÉLq˜f†=¸¼'œE6œ
¤—6ê9…­'¬´ïoê|Æ,gáµÛb8^RŠAµn F†™x#?Ìc³KîÄë‹Ë6%·C8€Ú!Û3ğw°c¸ fZïXg/ÄÓ!¯4Hr>š¯ñIºK_tIºß±W`©BªËˆËôèBëÿüÓ¯q ğÍ¹ã¼w/Š“{÷õ´~İÄùCÆ{¿‘:ÆëæA>óˆÆØãò#ß»{sYÔƒ¿ËÍƒs+T˜Uû¶ğ½ÎŒTUÚS]“Õ‡‹úG™“aNÓÏ}››Èªe¡iê‰ÃöŠD«:ºXm™E”˜¾7 n}àY$n  6ÉÊmŒ@;p²ó­pš÷ê²G¿PKÁI OTìóü.ª¯¥­C#à›;®ã¤ö§È%ìÌ˜IJcUçóPõ.^f¸H°†’$aÍ“@Ê„fU;áÛ~¡4 b¶Şá¿?éBB8ÿ_GM¯PxıßÁæÖ½ÿÏ™½¯ç{‡æõvÀ¡MúÂB¥êcöC˜éYÏ-ÛmŸÉ4°/ŒËù„ècÖ¦ºR*UóB iQ×¸håêy¶ÉÚ9W¸¢4Qqõu®<vPoLJà¥GiøIñ÷Ïó­èÍúJ±‘Ì4™Uğ^XşÁ«,éhªgå6Š;ºŠïe3½8¸Iiü•éS¸ÍÒƒaàíËXô1a¸àyM|òŸh‡eZóvû,tşÜÒ8¨ÍrÆ[Œ©DÍUŒ6©ˆH'âï÷@ëy:ı®>æÿ)qÃwG bb÷Ü]Lôò\KF}ãşÑ,4Õ’}_ÍÑVÑÇ‘eZAX“{(–”ƒÙá ÿ`ÍÿX?¹í@aş¤cšCÉIû²?dáBŠt½†1Lù€ìª{G(>ëy0ÑŒVœßü.@l“éÚ?~¾2±ÛÑ§7éwõœL¸È´A`[µëÅ­Æ—HØúæÍİ/«÷ó£«„Ëƒ qÛôòâ#Å½§I±y8Ÿó1"A ı*ÿëQ5…?`²XTûêt-nfüx¢¥ÏZo~ŞêŸÛcå¦Î›¨;£¯møs2×ËzwÜ‡y=ÑöÎã_~	xôüò¼xÃÒê…xJõá SÅz&<_‘gÑ ŞÕAÖö‹?‚i-ZM–¦jN¨m ¨3MêÊ3á¿–¨ƒ@ıçN½Kôt˜³@¹Ië’'vd²Z„ÑâËJG‘¸ùuÌ¤HQËíEGrƒ8B®`Â”Wêæ’VyñYZ@(	d}Ì>m…? ’6üÒkÍÿ·1B×;æ=ö`DŞº+ĞÄŸyÉFuÂXš—:7÷§nĞ×±µaÍ¿
Ş¾e°…m•ñ1~]5u¨÷ÂõĞ,ŞwÀE±ğ#!ŒlÎ`£äµÒ½ÍKÀ÷4Û³Çºı¬ÙC¤İŸW{MB3/×Ö+WãêÔí”´—±â±'#/v—×A¹F)ÚibÈv™roQ½gæ€ßÂ\™â"/>2=®~Bëïûd3Û;"–Å—ò³kãè€ì†¼¼£Íœ8·bE¥ŸğG•:ÚuDØcMWÍ„Î½rnúsÕÇØR£ÿô}êYÅ2LMünîbÅÒvşíWµQ@<ô¿`ŞÄİä4Aˆ“N=
.¦+t®è£µ„ Fe2dĞI2Nø2c†p1÷f¿œ& ï±ú3r,L®(ê³ÑÀt½OØåèªh¨¤ :Ã.M”
:(ÒÎëä%ğY1‹^(¤âë<¢RİæU®÷Šëa}äáCÕšÆ‹¥
VïÅß8üOv¤$Qdæ<BØY·c¤ÌƒÔAG„KqOiİûG‡*ö¾ãûç¿¹°€‰‚¸Í(úV\f¤cS‡z¬ŠryÃß/–èXX²:.‘Ã7,7cœ9¹ª\kJ´šŸez'\µ„«ÔCÂì„?­óÙ_…Í7¾•³g_”…’Yú=­^m‡¢ê.6sz‡Á®Œk1håwt»îI3ïDh¿Ì"óÙH1—‘Ø—âÛŠŞ#låÄ7¼è‘ï=5H9¦zíË„„hDŞÂ1çİJÏJå¤ÂõŸoW…C:iOà,ÿQD°†'´œ&CrÕÄß,Ó­æSŸœÊ+ŠÅWvT’%tÍ2¾Ë}*(^Š„¼åå`ÖCG2—‹mUÒWTÏ‰YXó[@yµ­~\LFŠÙ\ğ:S‘JW‚ï1\sÓ9²„ê‘ß˜;š(êÚ—ÂËåÓg­Iz­ÀÅŞA5
(–;”âGÚÿô0³pìş²ˆ/ß"T[™®X”¿Bòı½LRŸXRú,ŸûüV ö0èj% ÿúuüYñC\¨R%ËMpã·ôé€­~~`iØê×2¢±iªÏ¦Â#1LµÏQÑ-(nà-”ëÀ·.~İ?éRIü²)Ïj8Ü°`{Y‰z^,±dì&Ÿ<ıË_³¼kåÔím,š|Ñ¦å4«Ùòmp¶ˆ7M
©t+q7Süù.?u2jôö<EßÅÿ±Í›oß\ö¥b­³ˆ›·»|ëQ¥ëtüİh{wjí šeA“*Ñ@À<¡jf=§¹Øv(´ÚÓş>•¯gïn¸÷à;°ôpW¹À$Ó/˜¥ú4Tk¡>u‡&€ašu]`¢=š¥hƒ2ı×<gî×@l5À²yÕó€f<‹·‡ÎDV§h,÷åLŒ[qu‚oÂ4·;…‘ V zsnT4ÒP[FI‰
×ğW™ên•ªfÍH†¤ß¼®¯2ÂÍ¤CºÊ©:öş„Æ=Ù¡ª]$ óúÄê ©µ¾ªòñ¿\*8îEèNZŠdÑÀğà=±»UWw´oÆõ³ëHu-Mõ3ThÀ.ÿ…= U
Ò,×}Piî¹hîeÁ«í£¦ƒ ì“KTòjè‘F«Á+JÀ_Dx¿œ²Ö¦hA¡Æ­`nñ{N–ˆ#8ş<	Âšì­ƒœ|Q7Ãâc»ÄšÙ½š¾—çr¹~¹HPÙEĞp$zA;€³h°àomW9ø¾Íı¸âb··Ÿ‡L¹»-'·e‚ğFÑS^ªqô¼9”nQ	{úÕ„Õ—Ñ¥1ş€´„ë+¼}/[¶×5:¯æ‰è™q$ø®1èÃy¸‘§˜×+A?×ƒòî/&WUÁ|¤I©ÛÒ‡;å°hAòé7±’{ØºGaNR•µ‹!)ìŠwú7+û_é³'(‚(Ä!Ã5+á0HÓS„XÅî·¨“&h;À[-şÿsÑ’\À|° ~rï2í<–{´1ñM-æö(Ú,9í®Ù,òn‹Ei"ışÚıª¡%‰µ2hgF>—Kßåo‹ÑÓ‡ûíí›p&¶.ÌâDã —Iwt¥ÊOk(ËH}İ\¶Í‡kM+ŸkFZ°	ÛZ§/oÄµıŸãîKûĞ¸}¦éë·‹«ÃA½œml}ƒÚ<k£l‰µô×/°™»”‹w—6³à%éGõ_mñ|eÚÇØëz©´?$Û¹ş8öíÊ0´îÌD8ÄBqZ©åä9qÚP_}-ûF’®0*t»šù{–m&l?O?Çr¿¿Ÿ/‘h¥Õ \¶/6Ió×Ñó|11ø~ÂõºIW#ó£ô;*…˜£b³‡ZûÅ_õ _ I~KÈ“ì@¾‡È¼dv¤3r®/PædÎ{—‹ÚY6Š÷“ùõxÍS0MªÌG`Q›76D"w€i´†@ß’˜R of this Long and the specified.
 * @this {!Long}
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @this {!Long}
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
  else
    return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
  else
    return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits < 32) return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >>> numBits, this.unsigned);
  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
  return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits rotated to the left by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotateLeft = function rotateLeft(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = (32 - numBits);
    return fromBits(((this.low << numBits) | (this.high >>> b)), ((this.high << numBits) | (this.low >>> b)), this.unsigned);
  }
  numBits -= 32;
  b = (32 - numBits);
  return fromBits(((this.high << numBits) | (this.low >>> b)), ((this.low << numBits) | (this.high >>> b)), this.unsigned);
}
/**
 * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotl = LongPrototype.rotateLeft;

/**
 * Returns this Long with bits rotated to the right by the given amount.
 * @this {!Long}
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotateRight = function rotateRight(numBits) {
  var b;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b = (32 - numBits);
    return fromBits(((this.high << b) | (this.low >>> numBits)), ((this.low << b) | (this.high >>> numBits)), this.unsigned);
  }
  numBits -= 32;
  b = (32 - numBits);
  return fromBits(((this.low << b) | (this.high >>> numBits)), ((this.high << b) | (this.low >>> numBits)), this.unsigned);
}
/**
 * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Rotated Long
 */
LongPrototype.rotr = LongPrototype.rotateRight;

/**
 * Converts this Long to signed.
 * @this {!Long}
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned)
    return this;
  return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @this {!Long}
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned)
    return this;
  return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @this {!Long}
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @this {!Long}
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high,
    lo = this.low;
  return [
    lo & 0xff,
    lo >>> 8 & 0xff,
    lo >>> 16 & 0xff,
    lo >>> 24,
    hi & 0xff,
    hi >>> 8 & 0xff,
    hi >>> 16 & 0xff,
    hi >>> 24
  ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @this {!Long}
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high,
    lo = this.low;
  return [
    hi >>> 24,
    hi >>> 16 & 0xff,
    hi >>> 8 & 0xff,
    hi & 0xff,
    lo >>> 24,
    lo >>> 16 & 0xff,
    lo >>> 8 & 0xff,
    lo & 0xff
  ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long(
    bytes[0] |
    bytes[1] << 8 |
    bytes[2] << 16 |
    bytes[3] << 24,
    bytes[4] |
    bytes[5] << 8 |
    bytes[6] << 16 |
    bytes[7] << 24,
    unsigned
  );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long(
    bytes[4] << 24 |
    bytes[5] << 16 |
    bytes[6] << 8 |
    bytes[7],
    bytes[0] << 24 |
    bytes[1] << 16 |
    bytes[2] << 8 |
    bytes[3],
    unsigned
  );
};

export default Long;
